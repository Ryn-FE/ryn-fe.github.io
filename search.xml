<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>下一代web工具-vite实践</title>
      <link href="/2021/08/%E4%B8%8B%E4%B8%80%E4%BB%A3web%E5%B7%A5%E5%85%B7-vite/"/>
      <url>/2021/08/%E4%B8%8B%E4%B8%80%E4%BB%A3web%E5%B7%A5%E5%85%B7-vite/</url>
      
        <content type="html"><![CDATA[<h2 id="vite-为什么出现"><a href="#vite-为什么出现" class="headerlink" title="vite 为什么出现"></a>vite 为什么出现</h2><p>在很久以前，浏览器上是没有 ESM 的，缺少对于模块化的支持，从页面中引入 js 的方案一般都是通过 script 进行加载，后来出现了比如 requirejs，commonjs 等相关的方案，之后随着技术的不断进步，我们又出现了 bundle 的方案进行一些模块化的引入，通过 webpack，rollup 等工具的 plugins 进行模块化打包。当然随着我们的项目的日益壮大，业务需求的不断完善，导致我们的工程越来越大，工程的启动时间和 热更新时间越来越长，每更新一次我都会去饮水机那接杯水喝一口，回来之后都不一定能够 OK。很大程度上影响了我们的开发效率和体验，性子比较着急的人当时可能内心就存了一团火，然后发泄给了 PM，出的这是什么需求，但是并不是需求的问题，当然也可能就是需求不爽。</p><p>那 vite 就是基于这样一个背景，来解决上述难题，当然不能解决需求问题，这点我认为它做的不够好。</p><h2 id="vite-为什么能够解决上述问题"><a href="#vite-为什么能够解决上述问题" class="headerlink" title="vite 为什么能够解决上述问题"></a>vite 为什么能够解决上述问题</h2><p>要了解上述问题，我们首先要知道 webpack 的 dev server 是怎么启动的。</p><p>Bundle-Based Dev Server</p><p>首先来说它们都有一个对应的 js 入口，然后通过入口 js 进行扫描应用的子模块，当这些模块被解析的时候，当然一些动态的模块也会被解析，当这些模块被 bundle 之后，它会把这些 bundlejs 注入到 html 当中，然后才会启动 dev server，等待页面的访问。从这之中我们就能看到整个过程存在的一些问题。首先他会找到整个应用所依赖的所有模块，这也正是导致我们项目变大之后启动就会变的很卡的一个主要原因。虽然有很多模块都是动态加载的，但是要进行对应的 chunk 到 bundle 的操作，其实并不是真正意义上的动态加载。其必须等待所有模块构建完成，即使是分片的模块也需要构建。</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-8-8/1628353848982-image.png" alt="Bundle-Based Dev Server"></p><p>ESM-Based Dev Server</p><p>ESM 是 es6 提出的概念，也就是可以原生支持 import，当然你得在 script 标签上增加一个 type=’moudle’的属性。当你 import 某一个模块的时候，浏览器会发一个对应的请求，举个例子</p><iframe height="300" style="width: 100%;" scrolling="no" title="es6_import_test" src="https://codepen.io/callren/embed/preview/xxdavxo?default-tab=html%2Cresult&theme-id=light" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/callren/pen/xxdavxo" target="_blank" rel="noopener">  es6_import_test</a> by 任亚楠 (<a href="https://codepen.io/callren" target="_blank" rel="noopener">@callren</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><p>这个页面中 html 在 import 的时候，会相应的发一个请求，请求到对应的依赖包之后执行对应的 js 文件</p><p>vite 启动的服务是以 index.html 为入口，然后进行对应的解析，找到我们的入口 js 文件，然后再加载下面的子模块，首屏只有少量的 js 模块，其它的一些动态的 js 模块是不需要被加载的，所以不需要 bundle 也能提升我们的页面性能</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-8-8/1628354171275-1628354100768.png" alt="ESM-Based Dev Server"></p><p>当然除了上述的不需要 bundle 提高性能以外，ESM 也存在其对应的一些问题，因为 vite 是动态转换的，所以实时转换的一个性能是 vite 面临的一个最大的问题</p><ul><li>transform 的性能问题<ul><li>尽可能使用性能高的工具</li><li>缓存 transform 的结果（浏览器缓存+HTTP 缓存）</li></ul></li><li>非 ESM 模块的一个兼容性问题（TS/JSX…）<ul><li>esbuild 进行转换，代替 TSC/Babel</li><li>es-module-lexer 扫描 import 语法</li><li>magic-string 重写 Node 模块的引用路径</li><li><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-8-8/1628354982634-1628354967066.png" alt="magic-string"></li></ul></li><li>Broswer ESM 不能加载 Node 模块<ul><li>Node CJS 模块的兼容，转换成 ESM 模块</li><li>模块请求数量较多</li><li>依赖预优化，将 Node 模块打包成一个文件，缓存，根据模块元信息对其进行对应的转换，支持 CJS 模块的 Named import</li><li>整个操作很耗性能，存在.vite 文件夹，下次再启动的时候检测版本进行复用</li></ul></li><li>Node 模块一些其它问题<ul><li>依赖预优化工具</li><li>v1: Rollup + @rollup/plugin-commonjs</li><li>v2: esbuild 依赖扫描，包装</li></ul></li></ul><h2 id="ESM-HMR"><a href="#ESM-HMR" class="headerlink" title="ESM HMR"></a>ESM HMR</h2><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-8-8/1628355736196-1628355729250.png" alt="ESM HMR"></p><ol><li>构建模块依赖图</li><li>如果模块含有 import.meta.hot.accept 则将模块标记成 boundary</li><li>当文件变更时，根据模块依赖图寻找 boundaries</li><li>boundaries 重新加载变更模块并执行更新</li><li>如果没有查找到 boundaries，页面重新加载</li></ol><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-8-8/1628356351198-1628356344893.png" alt="ESM HMR"></p><h2 id="上线方式"><a href="#上线方式" class="headerlink" title="上线方式"></a>上线方式</h2><p>但是由于浏览器一些加载性能的问题，我们真正在上线代码的时候还是需要做对应的打包。可以做代码分片，压缩等一系列的事情。使用现有的 rollup 的方式</p><p>优势：</p><ol><li>基于 ESM bundler，和 vite 契合</li><li>打包产物体积小，执行速度快</li><li>plugin API 灵活，比 webpack 更灵活</li><li>ESM Tree-Shaking</li><li>Bundle Code Size</li><li>成熟稳定的生态</li><li>常用来打包 library</li></ol><p>劣势：</p><ol><li>配置 web app 比较复杂</li><li>framework 支持度</li></ol><p>vite：</p><ol><li>内置了并简化了这些配置</li><li>提供了 framework 模版（vue3，react，svelte，preact）</li><li>内置常用 plugins（TS/JSX，PostCSS，CSS Modules，Assets…）</li><li>继承 rollup plugins，并进行了扩展，SSR 支持等</li><li>dev 支持 rollup plugins</li><li>Node 环境加载 ESM，支持 HMR+Plugin</li></ol><p>如有疑问，欢迎留言</p><h2 id="前端构建工具剖析"><a href="#前端构建工具剖析" class="headerlink" title="前端构建工具剖析"></a>前端构建工具剖析</h2><ol><li>收集依赖</li><li>es6 转 es5 transform</li><li>替换 require 和 exports</li></ol>]]></content>
      
      
      <categories>
          
          <category> vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题目+答案汇总</title>
      <link href="/2021/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE-%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB/"/>
      <url>/2021/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE-%E7%AD%94%E6%A1%88%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="箭头函数的-this-指向"><a href="#箭头函数的-this-指向" class="headerlink" title="箭头函数的 this 指向"></a>箭头函数的 this 指向</h2><ol><li>箭头函数没有 this，所以需要 通过查找作用链来确定 this 的值</li><li>箭头函数没有自己的 arguments 对象</li><li>不能通过 new 关键字调用</li></ol><p>ps: this 指向是在函数执行的时候确定</p><h2 id="JS-模块化"><a href="#JS-模块化" class="headerlink" title="JS 模块化"></a>JS 模块化</h2><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><ul><li>自执行函数</li><li>AMD 使用 requirejs 来编写模块化（依赖必须提前声明好）</li><li>CMD 使用 seajs 编写模块化，动态依赖引入文件</li><li>CommonJS nodejs 中自带模块化</li><li>UMD 兼容 AMD CommonJS 语法</li><li>webpack 代码分割</li><li>ES Modules 标签增加 type=’module’</li></ul><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-7-14/1626266600270-98b86f3719894fafb334cedc6555079a_tplv-k3u1fbpfcp-zoom-1.image" alt="模块化历程"></p><h3 id="AMD-和-CMD-的区别"><a href="#AMD-和-CMD-的区别" class="headerlink" title="AMD 和 CMD 的区别"></a>AMD 和 CMD 的区别</h3><p>对依赖模块的执行时机处理不同</p><ul><li>AMD 依赖前置，定义模块的时候就要声明依赖模块</li><li>CMD 就近依赖，用到了之后才去 require</li></ul><h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><ol><li>所有代码都运行在模块的作用域，不会污染全局</li><li>模块同步加载，引入的模块加载完成才会进行后续操作</li><li>模块有缓存</li><li>输出的是值的拷贝</li></ol><h3 id="ES6-modules-特点"><a href="#ES6-modules-特点" class="headerlink" title="ES6 modules 特点"></a>ES6 modules 特点</h3><ol><li>输入的变量不可重新赋值，可读引用，可以改写属性</li><li>export 和 import 处于模块顶层</li><li>babel 会把 export/import 转换成 exports/require 的形式</li></ol><h3 id="CommonJS-和-ES6-modules-的区别"><a href="#CommonJS-和-ES6-modules-的区别" class="headerlink" title="CommonJS 和 ES6 modules 的区别"></a>CommonJS 和 ES6 modules 的区别</h3><ol><li>CommonJS 运行时加载，ES6Modules 是编译时加载</li><li>CommonJS 输出值的拷贝，ES6Modules 输出值的引用</li><li>前者导入模块是一个表达式，后者导入只能是字符串</li><li>前者 this 指向当前模块，后者 this 指向 undefined</li><li>ES6Modules 中没有 arguments、require、module、exports、_filename、_dirname 这些顶层变量</li></ol><h2 id="addEventListener-的第三个参数是什么"><a href="#addEventListener-的第三个参数是什么" class="headerlink" title="addEventListener 的第三个参数是什么"></a>addEventListener 的第三个参数是什么</h2><ul><li>当为 boolean 时，true 为捕获，false 为冒泡</li><li>当为 Object 时：capture，布尔值，捕获阶段传播到该 dom 时触发。once，布尔值，是否只调用一次，passive，布尔表示 listener 永远不会调用 preventDefault</li></ul><p>冒泡：从下层到上层传递 捕获：从上层到下层传递</p><p>创建自定义事件 new Event，customEvent，document.createEvent&amp;initEvent，触发 dispatchEvent</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>可以访问函数中变量</li><li>可以使变量长期保存在内存中</li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol><li>循环引用</li><li>自动类型装箱转换</li><li>某些 dom 操作</li><li>闭包</li></ol><p>程序中提示内存不足不是内存泄漏，一般是无限递归函数调用导致栈内存溢出</p><p>内存泄漏一般指的是堆内存泄漏，栈区不会泄漏</p><p>基本数据类型保存在栈内存，但是闭包中的数据类型存储在堆内存。引用数据类型实体存储在堆内存，栈中存储了指针</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li>整个 script 作为一个宏任务进行执行</li><li>同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li><li>当前宏任务执行完成之后，检测微任务列表，有则进行微任务执行，直到微任务列表全部执行完毕</li><li>执行浏览器的 UI 线程渲染工作</li><li>检查是否有 web worker 任务，有则执行</li><li>执行完本轮宏任务，回到第二步，依次循环，直到宏任务和微任务队列都为空</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac电脑重装所需软件一览</title>
      <link href="/2021/07/mac%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E6%89%80%E9%9C%80%E8%BD%AF%E4%BB%B6%E4%B8%80%E8%A7%88/"/>
      <url>/2021/07/mac%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E6%89%80%E9%9C%80%E8%BD%AF%E4%BB%B6%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>作为一个前端，电脑重装的时候我们需要哪些软件</p><ul><li>git</li><li>node</li><li>item2</li><li>oh my zsh</li><li>pnpm</li><li>vscode</li><li>baacloud</li><li>utools</li></ul><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p><a href="https://pnpm.io/zh/motivation" target="_blank" rel="noopener">https://pnpm.io/zh/motivation</a></p><pre><code class="ssh">npm install -&gt; pnpm installnpm i &lt;pkg&gt; -&gt; pnpm add &lt;pkg&gt;npm run &lt;cmd&gt; -&gt; pnpm &lt;cmd&gt;// 初始化应用pnpm create-react-app my-projectnpx -&gt; pnpx</code></pre>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解react router</title>
      <link href="/2021/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react-router/"/>
      <url>/2021/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react-router/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器导航相关"><a href="#浏览器导航相关" class="headerlink" title="浏览器导航相关"></a>浏览器导航相关</h2><p>URI（统一资源标识符）的通用语法： <code>URI = scheme:[//authority]path[?query][#fragment]</code></p><p>其中 authority 可由以下三部分组成：<code>authority = [userinfo@]host[:port]</code></p><p>fragment 为片段标识符，通常标记为已获取资源的子资源，可选</p><p>URL 为 URI 的一种，统一资源定位器</p><p>未保留字符不需要进行百分号编码<code>（a~z, A~Z, 0~9, - _ . ~）</code>共 66 个，保留字符需要进行对应的编码，因为其有特殊的含义在 URL 中。<code>（!*&#39;();:@&amp;=+$,/?#[]）</code>共 18 个</p><p>encodeURI 对 66 个未保留字符，18 个保留字符，除去<code>[]</code>，不对这 82 个字符编码，对于非 ASCII 字符，其将转换成 UTF-8 编码字节序，然后放置%进行编码，也就是会将中文等字符进行编码</p><p>encodeURIComponent 将转义除字母、数字、( ) . ! ~ * ‘ - _ 以外的所有字符。encodeURI 适合对一个完整的 URI 进行编码，而 encodeURIComponent 则被用作对 URI 中的一个组件或者一个片段进行。</p><p>浏览器记录没有直接的 api 可以获取，可以通过 window.history.length 来获取当前记录栈的长度信息。由浏览器统一管理，不属于哪一个具体的页面。</p><pre><code class="JavaScript">interface History{    readonly length: number;    scrollRestoration: &#39;auto&#39; | &#39;manual&#39;;    readonly state: any;    back(): void; // 栈指针后退一位    forward(): void; // 跳转到当前栈指针所指前一个记录的方法，等同于history.go(1)，是否刷新取决于栈记录是如何得到的    go(delta?: number): void; // -1表示后退到上一个页面，1表示前进一个页面，0表示刷新当前页面，与location.reload方式行为一致，此方法会刷新页面，会触发popstate事件，pushState永远产生新的栈顶并指向它    pushState(data: any, title: string, url?: string | null): void; // 无刷新增加历史栈记录，改变浏览器的url，有中文也会URF-8编码，即便浏览器显示的还是中文，但是已经是编码过的。第一个参数是传入的状态，设置了第一个参数之后，可以通过history.state读取。firfox中state大小限制640k，并且跳转的url有同源策略。执行一次会增加一个历史栈，history.length会发生对应的变化，即使url参数不传。data对象采用了结构化拷贝算法，对象中不能设置函数    replaceState(data: any, title: string, url?: string | null): void; // 类似pushState，但是是修改当前的历史记录，不处于栈顶的情况下修改的也是当前的，且不会将指针指向栈顶，history.length不会发生变化。url同pushstate都支持绝对和相对路径    // 当前路径为/one/two/three    // window.history.pushState(null, null, &#39;./four&#39;)    // 当前路径为/one/two/four    // window.history.pushState(null, null, &#39;./&#39;)    // 当前路径为/one/two/    // 当前路径为/one/two/    // window.history.pushState(null, null, &#39;four&#39;)    // 当前路径为/one/two/four}</code></pre><p>调用 history.pushState 改变 search 的值时，hash 的值会被清理</p><p>base 元素存在的情况下，进行添加和修改浏览器记录<code>&lt;base href=&#39;/base/bar&#39;&gt;</code>，pushState 以/开头的绝对路径跳转的时候，base 是被忽略的，如果是相对路径，则会使用 base 作为基准</p><p>window.location.href 与 window.location 行为一致，与 pushState 不同的是其可以刷新对应的页面并重新加载 URL 指定的内容</p><p>window.location.hash 改变 URL 的 hash 值，改变 hash 同样会产生新的历史栈记录，如果设置的 hash 与当前的 hash 值相同，则不会产生任何事件和历史记录，如果改变 hash 不进行入栈的操作，通过 location.repalce 来实现</p><p>window.location.replace 替换栈记录，设置绝对路径时，会刷新页面</p><p>当移动栈指针的时候会触发 popstate 事件，通过 window.addEventListener 进行监听，对于回调函数的 event 事件，event.state 是重点关注的，其值为移动后栈中记录的 state 对象。pushState 以及 repalceState 不会触发 popstate 事件。当然你也可以使用 history.state 来获取 state 对象。location.href 设置 hash 的时候，一样的 hash 也会触发 popstate，但是栈没变，location.hash 则不会触发 popstate。</p><p>hashchange 用来监听浏览器的 hash 值变化，pushState 不触发 hashchange 事件</p><p>可以调用 window.dispatchEvent(new PopStateEvent(‘popstate’))来主动出发 popstate 事件</p><h2 id="react-的-history-库详解"><a href="#react-的-history-库详解" class="headerlink" title="react 的 history 库详解"></a>react 的 history 库详解</h2><p>history 是一个单独的库，提供了 createBrowserHistory，createHashHistory，creatMemoryHistory。其中个历史对象都具备</p><ul><li>监听外界地址变化的能力</li><li>获取当前地址</li><li>增加和修改历史栈</li><li>在栈中移动当前历史栈指针</li><li>阻止跳转，定义跳转提示</li><li>获取当前历史栈长度以及最后一次导航行为</li><li>转换地址对象</li></ul><pre><code class="JavaScript">interface History&lt;HistoryLocationState = LocationState&gt; {    length: number;    action: Action; //最后一次导航的导航行为    location: Location&lt;HistoryLocationState&gt;; // 当前历史地址    push(path: Path, state?: HistoryLocationState): void; // 添加历史栈记录    push(location: LocationDescriptorObject&lt;HistoryLocationState&gt;): void; //重载方法    replace(path: Path, state?: HistoryLocationState): void; // 修改历史栈记录    replace(location: LocationDescriptorObject&lt;HistoryLocationState&gt;): void; // 重载方法    go(n: number): void;    goBack(): void;    goForward(): void;    block(prompt?: boolean | string | TransitionPromptHook): UnregisterCallback; // 阻止导航行为    listen(listener: LocationListener): UnregisterCallback; // 监听地址变化，传入一个回调函数，参数1为location，参数2为 action（不同的跳转类型），页面初始化不会触发。location前后值一致的情况下也会触发    createHref(location: LocationDescriptorObject&lt;HistoryLocationState&gt;): Href; // 地址对象转换}interface BrowserHistoryBuildOptions {    basename?: string;    forceRefresh?: boolean; // 跳转是否刷新页面，默认不刷新    getUserConfirmation?: typeof getUserConfirmation;    keyLength?: number; // 历史栈中栈记录的key字符串的长度，默认6    // ...通用配置}// browser history.push 底层使用history.pushState，无刷新，但是push会触发history的listen监听的回调interface History&lt;any&gt; {    push(path: string, state?: any): void;    push(location: {        pathname?: string;        search?: string;        state?: any;        hash?: string;    }): void;}// hashHistory 在创建hashHistory时，除了一些公共的配置，还可以设置hash类型，不可设置keyLength，forceRefresh配置type HashType = &#39;hashbang&#39; | &#39;noslash&#39; | &#39;slash&#39;; // 默认slash：其#号后面都会跟上/，noslash则#号后面都没有/，hashbang为#号后会跟上!和/，页面信息抓取用hashbang更好，页面初始化的过程中，encodedPath和hashPath不同，所以会进行一次初始化，因而每次会在页面后追加/#/</code></pre><p>window.location.replace 仅传入 hash 字符串的调用会将 window.location.pathname 改成 base 的值。后续高版本中修复了这个问题。监听还是采用 listen 的方式进行</p><p>history.createHref 可以将 location 对象转换成对应的 URL 字符串，不会对原字符做任何编码处理，其会判断文档流中有没有 base 元素</p><p>memoryHistory，basename 在此中不被支持，其所有的信息都保存在 location 中。</p><pre><code class="JavaScript">interface MemoryHistoryBuildOptions {    getUserConfirmation?: typeof getUserconfirmation;    initialEntries?: string[]; // 类似历史栈记录，默认[&#39;/&#39;]    initialIndex?: number;    keyLength?: number;}interface MemoryHistory&lt;HistoryLocationState = LocationState&gt; extends History&lt;HistoryLocationState&gt; {    index: number;    entries: Location&lt;HistoryLocationState&gt;[]; // 历史栈数组    canGo(n: number): boolean; // 是否可以跳转到位置n}</code></pre><p>history 库的整体运行流程</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-6-7/1623047216789-%E5%9B%BE%E7%89%87.png" alt="history"></p><p>问题：</p><ol><li>刷新页面后历史栈丢失</li><li>移动端限制</li><li>hash 路由问题，手动修改页面 hash</li></ol><h2 id="React-相关"><a href="#React-相关" class="headerlink" title="React 相关"></a>React 相关</h2><p>creatContext 创建 context 容器，Provider 提供跨层级数据，consumer 进行接收，如果传递的数据进行了对应的更新，触发 render，那么 Provider 会将最新的 value 传递给所有的 Consumer。当提供的数据更新时，没 Consumer 的组件不会触发更新。当有多个 Provider 时，Consumer 使用的是最近一级的 Provider 提供的值。</p><p>useEffect 不会阻碍浏览器的绘制，使用了一种特殊手段保证了 effect 在绘制后触发，其使用了 MessageChannel 的方式，结合 requestAnimationFrame 达到绘制完成后触发 effect 函数，effect 适合执行无 dom 依赖，不阻碍主线程渲染的副作用，如网络请求，事件绑定等。</p><p>对于清除副作用，每个 effect 都返回一个清除函数。执行的时机是在执行当前 effect 之前对上一个 effect 进行清除。除了每次更新会清除，在组件卸载的时候也会清除</p><p>第二个参数为依赖列表，那么 React 是如何知道依赖列表的值发生的改变呢？其通过 Object.is 进行元素前后的比较。其比较的是对象的引用。可以使用社区的 use-deep-compare-effect 方式进行比较</p><p>useEffect 特性</p><ol><li>Capture Value 特性</li><li>async 函数特性，由于 async 返回的是 promise，和 effect 函数返回的 clean 函数冲突</li><li>空数组依赖</li></ol><p>useLayoutEffect，都可从 DOM 中获取其变更后的属性。layoutEffect 运行是同步的，影响浏览器的渲染</p><p>useRef，不仅可以保存对应的 dom，current 属性还能保存一些数据，数据变化时 dom 不刷新</p><p>useMemo 用来缓存某些函数的返回值。使用缓存避免每次渲染都重新执行相关函数。<br>useCallback，等同于 useMemo(() =&gt; fn,deps)<br>useContext，调用了 useContext 的组件总会在 Context 值发生变化的时候重新渲染</p><p>自定义 hook，hooks 的基本准则，不能在条件循环中使用，不能在普通函数中使用</p><p>forwardRef 可以对 ref 进行传递</p><p>React.memo 可以对组件进行缓存，第二个参数可以决定是否渲染。不可以把 react.memo 放在组件渲染过程中</p><h2 id="认识-React-Router"><a href="#认识-React-Router" class="headerlink" title="认识 React Router"></a>认识 React Router</h2><p>Route Link history</p><p>StaticRouter 为静态路由，也称为无状态路由。通常在服务端 Nodejs 中使用。特征是在开发阶段或者程序运行前就已经确定<br>MemoryRouter 和 NativeRouter 在测试场景或 ReactNative 中使用较多</p><h2 id="Router-源码解析"><a href="#Router-源码解析" class="headerlink" title="Router 源码解析"></a>Router 源码解析</h2><p>三部分：history 监听，提供初始 context 以及提前监听</p><pre><code class="JavaScript">// history监听this.unlisten = props.history.listen(location =&gt; {    this.setState({ location })})// contextimport React from &#39;react&#39;import RouterContext from &#39;./RouterContext&#39;class Router extends React.Component {    static computeRootMatch(pathname) {        return { path: &#39;/&#39;, url: &#39;/&#39;, params: {}, isExact: pathname === &#39;/&#39; }    }    constructor(props) {        super(props)        this.state = {            // 初始location从history中获得            location: props.history.location        }        this._isMounted = false        this._pendingLocation = null        if(!props.staticContext) {            this.unlisten = props.history.listen(location =&gt; {                if(this._isMounted){                    // 仅在挂在成功后进行设置，防止出现未挂在成功而props.history.location已经变化的情况                    this.setState({                        location                    })                }else{                    // 先将最近的location变化挂载                    this._pendingLocation = location                }            })        }        componentDidMount() {            // 用于记录组件是否挂载成功            this._isMounted = true            if(this._ispendingLocation){                // 将挂载的location设置到state.location中                this.setState({                    location: this._pendingLocation                })            }        }        componentWillUnmount() {            // unmount在销毁时应该取消监听            if(this.unlisten) this.unlisten()        }        render() {            return (                &lt;RouterContext.Provider children={this.props.children || null} value={{                    history: this.props.history,                    // state.location发生了变化，触发重新渲染                    location: this.state.location,                    match: Router.computeRootMatch(this.state.location.pathname),                    staticContext: this.props.staticContext                }} /&gt;            )        }    }}export default Router// RouterContextimport createContext form &#39;mini-create-react-context&#39;const createNamedContext = mame =&gt; {    const context = createContext()    context.displayName = name    return context}const context = /* #__PURE__*/ createNamedContext(&#39;Router&#39;)export default context</code></pre><ul><li>useRouterContext：获得组件树中距离当前组件最近的 RouterContext 值，可获得 history、location、match</li><li>useHistory：获取 history 对象</li><li>useLocation：获取 location 对象</li></ul><h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><p>两个基本要素，path 和组件渲染方式。path 表示用来匹配何种浏览器路径，component 用来定义匹配成功后渲染哪个组件。匹配并渲染</p><ul><li>path：基本路径格式字符串、正则表达形式、综合形式，符合 Express.js 的路径声明风格，可传入数组。对于():*\需要转义，否则识别为正则符号，如果没有传入 path，那么其视为匹配成功</li><li>组件渲染方式：component 方式，render 方式</li><li>children 属性渲染：最高自由度，即便路由 path 没有 match，如果 child 不是函数，为 react 组件，则命中路由后才做对应的渲染。</li></ul><p>渲染优先级：children，component，render</p><p>对于 Route 组件的三个参数说明</p><ul><li>match 对象：params（路由匹配出的键值对），isExact（是否完全匹配），path（匹配到的路由的 path 属性），url（真实的 url 匹配命中的部分）</li><li>location 对象：key 在 hash 路由下不存在，为 null，在浏览器路由中为一个随机值。pathname 为 url 路径的 path 部分，search 为 query 部分，包括？，hash 为 hash 部分，包括#，state 对象，持久化存储状态。注意 hash 路由的 pathname 是从#后开始计算路由，解析 query 可以通过 new URLSearchParams(location.search)进行格式化</li><li>history 对象：建议每次使用 props 的 location 对象，而非 history 的 location 对象</li></ul><p>Route 的其它配置</p><ol><li>location，允许自行传入而不是使用上下文中的 location</li><li>exact，路由配置是否完全匹配</li><li>strict，路由严格模式</li><li>senssitive，路由大小写是否敏感，默认不敏感</li></ol><p>整体流程如下</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-6-22/1624329218023-%E5%9B%BE%E7%89%87.png" alt="router流程"></p><p>useRouteMatch，获取某路径的路由匹配情况或者获取上下文中的 match 命中情况<br>useLocation，获取当前的 URL 路径<br>useParams，获取上下文中的命名参数匹配结果，源码为使用 useContext 获得上下文中的 match，路由未命中时 match 为 null，命中之后返回 match.params<br>RouterContext 上下文跨组件获取组件树中距离本级组件最近的 Router 的匹配信息<br>IndexRedirect 组件的作用是在父路由命中的情况下，将父路由重定向到一个新的路由，在 Router4.x 版本以后被取消了，但是自己可以模拟实现</p><p>路由缓存问题：1. 状态存在 redux 等内存中 2. 不销毁 dom 节点 3.渲染优化</p><pre><code class="JavaScript">// CacheRouteimport * as React form &#39;react&#39;import { Route, RouteChildrenProps, RouteProps } from &#39;react-router&#39;import { omit } from &#39;lodash&#39; // 忽略对象中某些属性import MemoChildrenWithRouteMatch, { MemoChildrenWithRouteMatchExact } from &#39;./MemoChildrenWithRouteMatchExact&#39;// 文件内容如下MemoChildrenWithRouteMatchExact startinterface Props extends RouteChildrenProps {    children?: any;}function MemoChildrenWithRouteMatch(props: Props) {    return props.children}export default React.memo(MemochildrenWithRouteMatch, (prvious, nextProps) =&gt; {    // 不命中就不渲染，仅在match有值才渲染    return !nextProps.match})function MemoChildrenWithRouteExactMaatch(props: Props){    return props.children}export const MemoChildrenWithRouteMatchExact = React.memo(MemoChildrenWithRouteExactMatch, (prvious, nextProps) =&gt; !(nextProps.match &amp;&amp; nextProps.match.isExact))//MemoChildrenWithRouteMatchExact endimport Remount from &#39;./Remount&#39;// 文件内容如下Remount startexport default function Remount(props) {    // 初始化key    const keyRef = React.useRef(Math.random() + Date.now())    if(props.shouldRemountComponent) {        keyRef.current = Math.random() + Date.now()    }    return React.cloneElement(React.children.only(props.children), {        key: keyRef.current    })}// Remount endinterface Props {    forceHide?: boolean; // 强制隐藏    shouldRemount?: boolean; // 是否需要销毁组件并重新渲染dom    shouldDestroyDomWhenNotMatch?: boolean; // dom渲染模式为销毁模式    shouldMatchExact?: boolean; // 判断组件缓存时是全匹配还是模糊匹配}export default function CacheRoute(props: RouteProps &amp; Props) {    const routeHadRenderRef = React.useRef(false)    return (        &lt;Route            {...omit(props, &#39;component&#39;, &#39;render&#39;, &#39;children&#39;)}            children={                (routerProps: RouteChildrenProps) =&gt; {                    const Component = props.component                    // 获取Route命中结果                    const routeMatch = routeProps.match                    let match = !!routeMatch                    if(props.shouldMatchExact){                        match = routeMatch &amp;&amp; routeMatch.isExact                    }                    if(props.shouldDestroyDomWhenNotMatch){                        if(!match) routeHadRenderRef.current = false                        // 按react-router包中的Route逻辑                        if(props.render){                            return match &amp;&amp; props.render(routeProps)                        }                        return (                            match &amp;&amp; Component &amp;&amp; React.createElement(Component, routeProps)                        )                    }else{                        const matchStyle = {                            // 隐藏                            display: match &amp;&amp; !props.forceHide ? &#39;block&#39; : &#39;none&#39;                        }                        if(match &amp;&amp; !routeHadRenderRef.current){                            // 将渲染标记设置为true                            routeHadRenderRef.current = true                        }                        let shouldRender = true                        if(!match &amp;&amp; !routeHadRenderRef.current){                            shouldRender =false                        }                        // 选择对应的memo                        const MemoCache = props.shouldMatchExact ? MemoChiildrenWithROuteMaatchExact : MemeChildrenWithRouteMatch                        // css隐藏保留dom                        let component                        if(props.render){                            component = props.render(routeProps)                        }else{                            component = &lt;Component {...routeProps} /&gt;                        }                        return (                            shouldRender &amp;&amp; (                                {/* 提供css属性 */}                                &lt;div style={matchStyle}&gt;                                    {/* 提供remount能力 */}                                    &lt;Remount shouldRemountComponent={props.shouldRemount}&gt;                                        &lt;MemoCache {...routeProps}&gt;                                            {component}                                        &lt;/MemoCache&gt;                                    &lt;/Remount&gt;                                &lt;/div&gt;                            )                        )                    }                }            }        &gt;        &lt;/Route&gt;    )}</code></pre><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>Link 要从 react-router-dom 中引入，其 props 定义为</p><pre><code class="javascript">export interface LinkProps&lt;S = H.LocationState&gt;  extends React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; {  to: H.LocationDescriptor&lt;S&gt;;  replace?: boolean;  innerRef?: React.Ref&lt;HTMLAnchorElement&gt;;}</code></pre><p>如果不需要 a 标签发送 Referer 字段，可以设置 rel=”noreferrer”</p><p>NavLink，带激活状态的 Link</p><pre><code class="javascript">export interface NavLinkProps&lt;S = H.LocationState&gt;  extends LinkProps&lt;S&gt; {  activeClassName?: string;  activeStyle?: React.CSSProperties;  exact?: boolean;  strict?: boolean;  isActive?&lt;Params extends { [K in keyof Params]?:string }&gt;(      match: match&lt;Params&gt;,      location: H.Location&lt;S&gt;,  ): boolean;  location?: H.Location&lt;S&gt;;}</code></pre><h2 id="其它路由组件及方法"><a href="#其它路由组件及方法" class="headerlink" title="其它路由组件及方法"></a>其它路由组件及方法</h2><ul><li>Switch 路由匹配组件，跟 Route 结合使用</li></ul><h2 id="之后必备"><a href="#之后必备" class="headerlink" title="之后必备"></a>之后必备</h2><ul><li>结构化克隆算法</li><li>loadhash</li></ul>]]></content>
      
      
      <categories>
          
          <category> router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全栈前端学习相关内容笔记</title>
      <link href="/2021/06/%E5%85%A8%E6%A0%88%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/%E5%85%A8%E6%A0%88%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写常规代码总结</title>
      <link href="/2021/05/%E6%89%8B%E5%86%99%E5%B8%B8%E8%A7%84%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2021/05/%E6%89%8B%E5%86%99%E5%B8%B8%E8%A7%84%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="手写-call"><a href="#手写-call" class="headerlink" title="手写 call"></a>手写 call</h2><pre><code class="JavaScript">// func.call(this, a, b)Object.prototype._call = function(context, ...params){    if(typeof this !== &#39;function&#39;){        throw TypeError(&#39;type is fail&#39;)    }    let that = context || window    let symbol = Symbol(&#39;func&#39;)    that[symbol] = this    let result = that[symbol](...params)    delete that[symbol]    return result}</code></pre><h2 id="手写-apply"><a href="#手写-apply" class="headerlink" title="手写 apply"></a>手写 apply</h2><pre><code class="JavaScript">// func.apply(this, [a, b])Object.prototype._apply = function(context, params = []){    if(typeof this !== &#39;function&#39;){        throw TypeError(&#39;type is fail&#39;)    }    let that = context || window    let symbol = Symbol(&#39;func&#39;)    that[symbol] = this    let result = that[symbol](...params)    delete that[symbol]    return result}</code></pre><h2 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h2><pre><code class="JavaScript">// func.bind(this, a, b)Object.prototype._bind = function(context, ...params1){    if(typeof this !== &#39;function&#39;){        throw TypeError(&#39;type is fail&#39;)    }    let that = context || window    return (...params2) =&gt; {        this.call(that, ...params1,)    }}</code></pre><h2 id="手写-instanceof"><a href="#手写-instanceof" class="headerlink" title="手写 instanceof"></a>手写 instanceof</h2><pre><code class="JavaScript">function instanceof(L, R){    let l = L._proto_    let r = R.prototype    while(true){        if(l === null) return false        if(l === r) return true        l = l._proto_    }}</code></pre><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><pre><code class="JavaScript">function create(obj) {    function F() {}    F.prototype = obj    return new F()}</code></pre><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><pre><code class="JavaScript">class Promise {  constructor(executor) {    ...    // 初始化    ...   this.onFulfilledCbs = []; // 成功回调函数队列   this.onRejectedCbs = []; // 失败回调函数队列    ...  }  resolve(val) {    if (this.status === PENDING) {      ...      // 一旦状态改变，遍历函数队列将终值作为形参触发队列中的函数     this.onFulfilledCbs.forEach(fn =&gt; fn(this.value));    }  }  reject(err) {    if (this.status === PENDING) {      ...     this.onRejectedCbs.forEach(fn =&gt; fn(this.reason));    }  }  then(onFulfilled, onRejected) {    ...    // 当状态处于pending时   if (this.status === PENDING) {     // 向函数队列添加微任务回调函数     this.onFulfilledCbs.push(value =&gt; {       setTimeout(() =&gt; {         try {           onFulfilled(value)         } catch (e) { reject(e) }       })     });     this.onRejectedCbs.push((reason) =&gt; {       setTimeout(() =&gt; {         try {           onRejected(reason)         } catch (e) { reject(e) }       })     });   }  }}</code></pre><p>promise.all 以及 promise.race 两方面可以 forEach，如果是 all 的情况，values 看是否达到了数组，race 则直接 resove 外围的 promise</p><h2 id="new-模拟"><a href="#new-模拟" class="headerlink" title="new 模拟"></a>new 模拟</h2><pre><code class="JavaScript">function newOperator(ctor) {    if (typeof ctor !== &#39;function&#39;){        throw &#39;newOperator function the first param must be a function&#39;;    }    var args = Array.prototype.slice.call(arguments, 1);    // 1.创建一个空的简单JavaScript对象（即{}）    var obj = {};    // 2.链接该新创建的对象（即设置该对象的__proto__）到该函数的原型对象prototype上    obj.__proto__ = ctor.prototype;    // 3.将步骤1新创建的对象作为this的上下文    var result = ctor.apply(obj, args);    // 4.如果该函数没有返回对象，则返回新创建的对象    var isObject = typeof result === &#39;object&#39; &amp;&amp; result !== null;    var isFunction = typeof result === &#39;function&#39;;    return isObject || isFunction ? result : obj;}</code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron相关笔记总结</title>
      <link href="/2021/04/electron%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2021/04/electron%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>基础篇，工程篇以及实战。web技术构建跨平台桌面应用，chromium+nodejs+nativeAPI跨平台</p><p>如何判断某个项目是否是electron开发。首先进入项目目录，cd Contents目录，进入Frameworks目录，可以看到Electron Framework</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-4-28/1619611412121-shElectron.png" alt="识别Electron"></p><p>Electron的最小组成，由渲染进程，包体描述，主进程组成。</p><p>Chromium架构多进程，每个页面对应着渲染进程，Browser是主进程。node集成到chromium</p><p>NW可以兼容xp系统</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm install electron –save-dev</p><p>npm install –arch=ia32 –platform=win32 electron</p><p>npx electron -v</p>]]></content>
      
      
      <categories>
          
          <category> electron 桌面端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令及作用</title>
      <link href="/2021/04/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8/"/>
      <url>/2021/04/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="网站链接"><a href="#网站链接" class="headerlink" title="网站链接"></a>网站链接</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192</a></p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><ul><li>git init 将某个目录变成git可管理的仓库，隐藏的目录可以通过ls -ah看到隐藏目录</li><li>git add readme1.md readme2.md 将某个文件添加到仓库，可以写多个文件，空格分隔</li><li>git commit -m ‘some thing’ 把文件提交到仓库，-m后面跟随提交内容的说明</li><li>git status 当前仓库的状态</li><li>git diff 修改的内容比较</li></ul><h2 id="2-穿梭"><a href="#2-穿梭" class="headerlink" title="2. 穿梭"></a>2. 穿梭</h2><p>Git中HEAD表示当前版本，上个版本就是HEAD^，上上一个就是HEAD^^，向上一百个写成HEAD～100</p><ul><li>git log 历史记录，参数–pretty=oneline可以缩减输出信息</li><li>git reset –hard HEAD^ 当前版本回退到上一个版本，当然HEAD^也可以被替换成commit id</li><li>git reflog 记录每一次的命令</li><li>git diff HEAD – readme.txt 查看工作区和版本库里面最新版本的区别</li><li>git checkout – readme.txt 把某个文件在工作区的修改撤销，没有–表示切换到另一个分支</li><li>git reset HEAD readme.txt 把暂存区的修改撤销重新放回工作区</li><li>git rm 删除版本库中的文件</li></ul><h2 id="3-远程仓库"><a href="#3-远程仓库" class="headerlink" title="3. 远程仓库"></a>3. 远程仓库</h2><p>github为例，本地git和github之间是通过ssh加密的，所以需要一点对应的设置</p><p>创建ssh key，首先看用户主目录有没有.ssh目录，然后再看这个目录下有没有id_rsa和id_rsa.pub这两个文件，有的话跳转到下一步，没有的话进行对应的创建。id_rsa是私钥，id_rsa.pub是公钥</p><pre><code class="ssh">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><ul><li>git remote add origin git地址 把本地仓库关联到远端某个仓库地址</li><li>git push -u origin master 把本地仓库所有的内容推到远程，-u表示将本地的master分支和远程的master分支关联，以后推送可以简化</li><li>git remote -v 查看远程库信息</li><li>git remote rm origin 根据名字删除origin</li><li>git clone git地址 克隆远端仓库</li></ul><h2 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4. 分支管理"></a>4. 分支管理</h2><ul><li>git checkout -b dev 创建并切换到dev分支，也可以使用git switch -c dev</li><li>git branch dev 创建dev分支</li><li>git checkout dev 切换到dev分支，也可使用 git switch dev</li><li>git branch 查看当前分支</li><li>git merge dev 当前分支合并某个分支</li><li>git branch -d dev 删除dev分支</li><li>git merge –no-ff -m ‘merge with no-ff’ dev 禁用fast forward，-m创建一个新的commit</li><li>git stash 把当前工作现场储藏起来</li><li>git stash list 查看stash存储的内容</li><li>git stash apply stash@{0} 恢复，恢复之后stash内容并不删除</li><li>git stash drop 删除stash存储的内容</li><li>git stash pop 恢复的同时也删除</li><li>git cherry-pick 4c805e2 复制一个特定的提交到当前分支</li><li>git branch -D name 强行删除某一个未合并分支</li><li>git remote -v 查看远程仓库信息</li><li>git branch –set-upstream-to=origin/dev dev 指定本地分支与远程origin/dev分支的链接</li><li>git rebase 把本地未push分叉的提交历史整理成一条直线</li></ul><h2 id="5-标签管理"><a href="#5-标签管理" class="headerlink" title="5. 标签管理"></a>5. 标签管理</h2><p>标签作为一个版本库的快照</p><ul><li>git tag name 打一个标签，使用git tag查看所有标签，默认标签是打在当前的commit上面的</li><li>git tag v0.9 f52c633 给对应的commit打对应的标签</li><li>git tag -d v0.9 删除某个标签</li><li>git push origin tagname 推送某个标签到远程</li><li>git push origin –tags 推送所有标签</li><li>git push origin :refs/tags/v0.9 先删除本地的内容，再删除远端的内容</li></ul><h2 id="6-配置管理"><a href="#6-配置管理" class="headerlink" title="6. 配置管理"></a>6. 配置管理</h2><ul><li>git config –global color.ui true 显示颜色</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在vscode中使用vim系列</title>
      <link href="/2021/03/%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8vim%E7%B3%BB%E5%88%97/"/>
      <url>/2021/03/%E5%9C%A8vscode%E4%B8%AD%E4%BD%BF%E7%94%A8vim%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>在vscode中使用vim增强我的编码能力，其实一直以来都很想学习vim的编码方式，虽然我也知道这是一个艰难的过程，但是总归是要面对的，既然这个过程很痛苦并且不是很容易就能够将一些内容熟练掌握，那么就从这里给自己进行一个对应的记录，有什么看不明白或者不清楚的地方可以有一个随时翻阅的地方。顺便提一下，这个文章是看的国外一篇文章翻译过来的，对应的参考资料在文章末尾有附带上，可自行查阅。</p><p>vim很强，因为它难</p><h2 id="在vscode中安装vim"><a href="#在vscode中安装vim" class="headerlink" title="在vscode中安装vim"></a>在vscode中安装vim</h2><ol><li>在扩展中搜索vim</li><li>排名第一的并安装它</li><li>要知道cmd+shift+p打开命令面板</li><li>cmd+p跳转对应的文件</li></ol><h2 id="vim基础"><a href="#vim基础" class="headerlink" title="vim基础"></a>vim基础</h2><p>刚开始的矩形光标，你会发现你想要输入的时候没有任何反应。当然，在你按下键盘的时候，有可能会触发一些特殊含义的命令，使得矩形光标在屏幕上飞来飞去，甚至删除了一些对应的内容。</p><p>那么所有这些都源自于vim的正常模式（也就是vim与文本的默认模式），并且在这个模式下，不会进行文本的插入。</p><p>那么什么是普通模式，模式又是什么意思？</p><h2 id="vim中的模式"><a href="#vim中的模式" class="headerlink" title="vim中的模式"></a>vim中的模式</h2><h3 id="1-普通模式NORMAL"><a href="#1-普通模式NORMAL" class="headerlink" title="1. 普通模式NORMAL"></a>1. 普通模式NORMAL</h3><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-3-20/1616173392387-image.png" alt="vim普通模式"></p><p>如何进入: esc ctrl+c ctrl+[</p><h4 id="四处移动并编辑文本或者跳转"><a href="#四处移动并编辑文本或者跳转" class="headerlink" title="四处移动并编辑文本或者跳转"></a>四处移动并编辑文本或者跳转</h4><p>w: 表示跳转到下一个单词<br>b: 向后跳到单词的开头<br>e: 跳转到单词的结尾<br>ge: 向后跳转到单词的末尾<br>j: 光标向下移动<br>k: 光标向上移动<br>h: 光标向左移动<br>l: 光标向右移动</p><h4 id="移动到特定角色"><a href="#移动到特定角色" class="headerlink" title="移动到特定角色"></a>移动到特定角色</h4><p>f{字符}: 后面跟上特定字符，移动到行中特定出现的那个字符上<br>t{字符}: 移动的位置比f前置一个字符<br>如果执行完搜索，可以使用;转到下一个字符，,转到上一个字符</p><h4 id="极端水平移动"><a href="#极端水平移动" class="headerlink" title="极端水平移动"></a>极端水平移动</h4><p>0: 移动到行的第一个字符<br>^: 移动到行的第一个非空白字符<br>$: 移动到行尾<br>g_: 移动到行尾的非空白字符</p><h4 id="垂直移动"><a href="#垂直移动" class="headerlink" title="垂直移动"></a>垂直移动</h4><p>}: 向下跳整段<br>{: 向上跳<br>ctrl+D: 向下移动半页<br>ctrl+U: 滚动半页<br>/{字符}: 向后搜索，一个文件中<br>?{字符}: 向后搜索，一个文件中<br>enter确定你搜索的内容，n跳转到下一个匹配的内容，N上一个，可理解为重复搜索</p><h4 id="计数可以更快的移动"><a href="#计数可以更快的移动" class="headerlink" title="计数可以更快的移动"></a>计数可以更快的移动</h4><p>2w: 向前移动2个单词<br>3j: 向下移动三行</p><p>gg: 跳转到文件顶部<br>{line}gg: 跳转到特定的某一行<br>G: 文件末尾</p><h4 id="编辑代码相关"><a href="#编辑代码相关" class="headerlink" title="编辑代码相关"></a>编辑代码相关</h4><p>{operator}{count}{motion}<br>{count}{operator}{motion}<br>例如：d2w 表示删除两个单词，motion可以和之前的移动结合起来，比如d5j表示向下删除5行。</p><ul><li>df’表示删除光标中当前行的所有内容，直到’字符第一次出现（删除包括字符本身）</li><li>dt’类似df’，但排除字符本身</li><li>d/hello，删除一切，直到第一次出现hello</li><li>ggdG删除整个文档</li></ul><p>d: 删除delete<br>c: change改变，合并了d和i操作符<br>y: yank复制<br>p: paste粘贴<br>=: format<br>g~: toggle case，更改大小写字母，也可以指定gU大写，gu小写<br><code>&gt;</code>: 添加缩进<br><code>&lt;</code>: 删除缩进<br>=: 格式代码</p><h4 id="速记语法"><a href="#速记语法" class="headerlink" title="速记语法"></a>速记语法</h4><p>将运算符加倍使其在整行上操作<br>dd: 删除整行<br>cc: 更改整行<br>大写表示其更强的版本<br>D: 从光标删除到行尾<br>C: 更改到行尾<br>Y: 复制完整的行<br>P: 在光标之前粘贴一些内容</p><h4 id="文本对象的操作"><a href="#文本对象的操作" class="headerlink" title="文本对象的操作"></a>文本对象的操作</h4><p>{operator}{a(所有)|i(除了符号)}{text-object}<br>w: 单词<br>s: 句子<br>p: 段落<br>b/(/): 用于()包围<br>B/{/}: 用于{}包围<br>&lt;/&gt;: 被&lt;&gt;包围<br>[]: 被[]包围<br>t: 标签</p><p>daw: 删除光标所在单词<br>ciw: 改变当前单词<br>das: 删除当前句子<br>da”: 删除”中的内容包括”，di”仅删除”内的内容<br>ci”: 更改”内内容<br>dap: 删除段落<br>dat: 删除标签以及内部内容<br>cit: 更改标签内内容</p><p>.按键可以保存上一次的操作命令<br>x等价于dl删除光标下的字符<br>X等价于dh删除光标之前的字符<br>s等价于ch删除光标下的字符并进入编辑模式<br>～切换单个字符的大小写<br>u撤销上一次的更改<br>ctrl+r重做</p><h3 id="2-插入模式INSERT"><a href="#2-插入模式INSERT" class="headerlink" title="2. 插入模式INSERT"></a>2. 插入模式INSERT</h3><p>进入这个模式有几种方式</p><ul><li>i在光标之前插入</li><li>a在光标之后插入</li><li>I在当前行开头插入</li><li>A在当前行之后插入</li><li>o在当前行下一行插入</li><li>O当前行上方插入</li><li>gi返回到你上次编辑的位置</li><li>ctrl+h删除你输入的最后一个文本</li><li>ctrl+w删除你输入的最后一句话</li><li>ctrl+u删除你</li></ul><p>插入文本</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-3-20/1616173059353-image.png" alt="vim插入模式"></p><h3 id="3-可视模式VISAUL"><a href="#3-可视模式VISAUL" class="headerlink" title="3. 可视模式VISAUL"></a>3. 可视模式VISAUL</h3><p>{trigger visual mode}{motion}{operator}</p><p>可视化操作下的选择方式</p><ul><li>v逐个字符选择</li><li>V逐行模式</li><li>删除某些内容，进入可视模式v，然后进行对应的选择比如按下j，最后输入d删除</li></ul><h3 id="4-复制粘贴"><a href="#4-复制粘贴" class="headerlink" title="4. 复制粘贴"></a>4. 复制粘贴</h3><ul><li>y 复制</li><li>yy 复制一行</li><li>p粘贴在当前光标后面</li><li>P粘贴在当前光标前面</li></ul><h3 id="5-命令行模式"><a href="#5-命令行模式" class="headerlink" title="5. 命令行模式"></a>5. 命令行模式</h3><ul><li>:edit+文件名 创建或者打开某个文件，简写:e</li><li>:q关闭文件 加上!表示强制执行操作 如:q!</li><li>:w保存文件，同上</li><li>:wq保存并关闭，组合命令</li><li>:wa保存所有文件</li><li>:qa关闭所有文件</li><li>:wqa保存关闭所有文件</li><li>都可以加上!强制执行</li><li>:1,3d 表示删除1，2，3行</li><li>:1,+2d 表示同上</li><li>:.,+2d 表示删除当前行和接下来的两行</li><li>:%d删除整个文件</li><li>:0,+10d删除文件开始十行</li><li>:.,$d从当前行删除到文件末尾</li><li>@:重复上一次命令</li><li>@@再次重复</li></ul><h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><p><code>:[range]s/{pattern}/{substitute}/{flags}</code></p><ul><li>:%s/hello/world 将整个文件中的hello替换成world</li><li>:s/hello/world 将当前行中的hello替换成world</li><li>flag: g全局搜索 i不区分大小写的搜索 c确认每一次替换</li></ul><h3 id="6-拆分窗口"><a href="#6-拆分窗口" class="headerlink" title="6. 拆分窗口"></a>6. 拆分窗口</h3><ul><li>:sp 文件名 水平平铺文件</li><li>:vsp 文件名 垂直平铺文件</li><li>ysaptli&gt; 用tag li标签包围一段文字</li></ul><h2 id="vscode中的快捷键"><a href="#vscode中的快捷键" class="headerlink" title="vscode中的快捷键"></a>vscode中的快捷键</h2><p>汇总vscode的快捷键</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] vscode中加入vim <a href="https://www.barbarianmeetscoding.com/boost-your-coding-fu-with-vscode-and-vim/table-of-contents" target="_blank" rel="noopener">https://www.barbarianmeetscoding.com/boost-your-coding-fu-with-vscode-and-vim/table-of-contents</a></p>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次性搞懂TCP/IP协议</title>
      <link href="/2021/03/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82TCP-IP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/03/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82TCP-IP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="七层网络协议"><a href="#七层网络协议" class="headerlink" title="七层网络协议"></a>七层网络协议</h2><p>也可以叫五层网络协议。应用层 -&gt; 传输控制层 -&gt; 网络层 -&gt; 链路层 -&gt; 物理层<br>其中应用层、表示层、会话层统称为应用层，一般来说程序都在应用层<br>三次握手，四次分手是在传输控制层<br>路由器IP是在网络层</p><h2 id="TCP相关"><a href="#TCP相关" class="headerlink" title="TCP相关"></a>TCP相关</h2><p>传输控制层，UDP/TCP</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>客户端给服务端首先发了一个syn的数据包，服务端返回一个syn+ack的数据包，然后客户端再回给服务端一个ack，建立起链接，开辟资源。所以说是面向链接的，可靠的</p><p>对于程序来说，条目就是一个soket，对资源的包装，接受队列和发送队列，程序和内核之间的交互，如何交互的IO模型。什么是soket，四元组，源ip+端口，目标ip+端口，绝对唯一的链接。一个系统里面能够分配的就是有65535个端口号</p><h3 id="四次分手"><a href="#四次分手" class="headerlink" title="四次分手"></a>四次分手</h3><p>资源释放的过程。任一方发出fin，因为是可靠的分手，所以对方会回一个fin+ack，说明我听到了，但是态度是不知道的，然后再回一个fin表示我也想跟你分手，然后发出方再回一个ack，此时便是4次分手。如果建立完三次握手，网断了，那么任何一方是否直到网断了这件事，是不知道的。内核有一个keepalive，也就是心跳</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级程序设计笔记</title>
      <link href="/2021/03/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/03/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-中的-JavaScript"><a href="#HTML-中的-JavaScript" class="headerlink" title="HTML 中的 JavaScript"></a>HTML 中的 JavaScript</h2><h3 id="script-元素属性"><a href="#script-元素属性" class="headerlink" title="script 元素属性"></a>script 元素属性</h3><ul><li>async：立即开始下载脚本，不能阻止页面其它动作，只适用于外部脚本，异步脚本保证会在页面的 load 之前执行，但可能会在 DOMContentLoaded 的之前或之后</li><li>charset：指定代码字符集</li><li>crossorigin：配置相关请求的 cors 设置，也就是跨域资源共享</li><li>defer：在文档解析和显示完成后再执行脚本，但是会立即开始下载，推迟执行，但是会在 DOMContentLoaded 事件之前执行，只对外部脚本有效</li><li>integrity：允许对比接收到的资源和指定的加密签名以验证子资源完整性</li><li>src：要执行代码的外部文件</li><li>type：代码块中脚本语言的内容类型，一般为’text/javascript’，如果为’module’，则代码为 es6 模块，只有这个时候代码中才能够出现 import 和 export 关键字</li></ul><p>一般来说代码块会被保存在解释器环境中，并且 js 代码在被解释的过程中，页面的其余内容不会被加载也不会被展示。在行内的 js 代码中，代码不能出现<code>&lt;/script&gt;</code>字符串，否则会报错，需要转义字符反斜杠，也就是 js 代码会阻塞页面的渲染。</p><p>如果<code>script</code>标签中包含行内代码并且 src 有值，浏览器会下载并执行脚本文件而忽略行内代码</p><p>页面在浏览器解析到 body 标签的时候才开始渲染</p><p>如果想让浏览器的预加载器知道一些动态请求文件的存在，可以在文档头部显示声明它们</p><pre><code class="HTML">&lt;link rel=&#39;preload&#39; href=&#39;preload.js&#39;&gt;</code></pre><p><code>&lt;noscript&gt;</code>标签中可以写入 html，以下两种情况会走<code>&lt;noscript&gt;</code>中的逻辑</p><ol><li>浏览器不支持脚本</li><li>浏览器对脚本的支持被关闭</li></ol><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><ol><li>区分大小写</li><li>标识符，也就是变量名称，函数名称等内容，最好驼峰命名法</li><li>注释，多行，单行等</li><li>严格模式，use strict</li><li>语句，最好加上分号，不然浏览器会自己判断在哪里加上分号，影响性能，代码块由{}包裹</li><li>关键字与保留字</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>局部作用于定义全局变量很难维护，定义多个变量可用逗号分割进行定义</p><ul><li>var 变量提升，可多次定义同一个变量，声明的范围是函数作用域，全局作用域下会挂在到 window 上</li><li>let 为块级作用域，暂时性死区（在 let 声明前的执行瞬间才叫暂时性死区），全局作用域下不会在 window 上</li><li>混用 let 和 var 都会冗余报错</li><li>const 在声明的时候必须付值，在 for 循环中，每次迭代创建一个新的变量是 OK 的，但是如果赋值那就 fail</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>简单数据类型：null，undefined，number，string，boolean，Symbol<br>复杂类型：object</p><p>typeof 是一个操作符而不是一个函数。</p><pre><code class="JavaScript">typeof null // &#39;object null值表示一个空对象指针&#39;typeof function // &#39;function&#39;typeof {} // &#39;object&#39;</code></pre><p>对于未声明或者未初始化的变量，只能对它执行一个操作就是 typeof，总是会返回 undefined。所以在做对应的声明的同时也要对应的对其做出初始化的操作，这样在使用 typeof 的时候就知道到底是未声明还是未初始化</p><p>undefined 是由 null 派生来的，因此其表面上相等。所以 null == undefined 为 true，任何时候只要是保存对象，而其又没有对应的值，就将其初始值设置为 null，这样能够和 undefined 区分开</p><p>可以用 Boolean()方法将其余的所有类型转换成 boolean 类型</p><pre><code class="JavaScript">Boolean(NaN) // false</code></pre><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><ul><li>八进制：第一个数字为 0 并且后续的数字为 0 ～ 7，如果后续的数字不为 0-7，则会忽略之前的 0，es6 的八进制的数字前缀为 0o</li><li>十六进制：数值前缀为 0x，然后是十六进制的数字，0-9 A-F/a-f</li><li>当其用作数学操作中的时候，则都会被视为 10 进制数值</li><li>科学计数法：1.3e10 表示 1.3 乘以 10 的 10 次幂，ECMAScript 会将小数点后至少包含 6 个 0 的数字转成科学计数法的形式</li><li>值的范围：最小值 Number.MIN_VALUE（5e-324）最大值 Number.MAX_VALUE（1.797 693 134 862 315 7e+308）如果某个计算数值超过了 MAX_VALUE，那么这个数值会被自动转换成 Infinity（无<br>穷），Infinity 不可用于任何计算</li><li>如何确定某个值是否有限大，使用 isFinite()函数，Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取正、负 Infinity</li><li>NAN 表示本来要返回数值的操作失败了，0/0 便会返回 NAN，NAN 不等于包括 NAN 在内的任何值。NAN == NAN 为 false，任何涉及 NAN 的计算都会返回 NAN，isNaN()函数可以判断一个参数是不是数字，注意 isNaN(‘10’)为 true，因为其可以转换成数字</li><li>isNaN 可用来测试对象，此时首先会调用 valueOf()，看其返回值是否是数字，否则再调用 toString()，测试其返回值</li><li>将非数值转换成数值方式：Number、parseInt、parseFloat，Number 可以用于任何数据类型，但是后面两个主要用于将字符串转换成数值<ul><li>Number 可以将 true 以及 false 转换成数值，null 返回 0，undefined 返回 NaN，字符串转成数字，空字符串返回 0，否则返回 NaN。对象来说先调用 valueOf 的方法，按照上述规则进行转换。如果是 NaN 则调用 toString 的方式进行转换</li><li>parseInt 会从第一个非空格字符开始转换，如果第一个字符不是数字字符，加减号，立即返回 NaN，所以空字符串也会是 NaN，但是’1234blue’会返回 1234，后续不是数字的字符会被忽略，类似 22.5 会被转换成 22，其第二个参数是要解析的字符的进制数</li><li>parseFloat 会忽略字符串开头的 0，十六进制数值始终返回 0.parseFloat 只解析十进制，不能指定底数，字符串表示整数，它会返回整数</li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符字面量</p><ul><li>\n 换行</li><li>\t 制表</li><li>\b 退格</li><li>\r 回车</li><li>\f 换页</li><li>\ 反斜杠</li><li>&#39; 单引号</li><li>&quot; 双引号</li><li>` 反引号</li><li>\xnn 以十六进制编码 nn 表示的字符</li><li>\unnnn 以十六进制编码 nnnn 表示的 Unicode 字符</li></ul><p>转义序列表示一个字符，如果字符包含双字节字符，那么 length 属性返回的可能是不准确的字符数</p><p>转换成字符串可使用 toString 方法，null 和 undefined 没有 toString 方法，toString 可以穿入一个参数，表示得到数值的哪种进制字符串。如果你不确定一个值是不是 null 或者 undefined，可以使用 String()函数，始终返回相应类型的值的字符串。内部的实现是如果有 toString 方法，则调用该方法（不穿参数）返回对应的结果。</p><p>用一个加号给一个值加上一个空字符串也可以将其转换成字符串</p><p>模版字符串：模版字符串内部的空格会被保留，在使用的时候要注意如果模版字符串是以一个换行符开头的话，那么其第一个字符全等于<code>\n</code>，任何通过${}插入的值都会被 toString()强制转换成字符串。标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模版和对每个表达式求值的结果。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果，函数返回值是对模版字面量求值得到的字符串</p><pre><code class="JavaScript">let a = 6let b = 9function simpleTag(strings, ...expressions){  console.log(strings)  for(const expression of expressions){    console.log(expression)  }  return &#39;foobar&#39;}let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`console.log(taggedResult)// strings: [&#39;&#39;, &#39; + &#39;, &#39; = &#39;, &#39;&#39;]// 6// 9// 15// 对于想把字符串和对表达式的结果拼接起来作为默认返回的字符串可以这样function zipTag(strings, ...expressions){  return strings[0] + expressions.map((e, i) =&gt; `${e}${strings[i + 1]}`).join(&#39;&#39;)}// 原始字符串console.log(`\u00A9`) // ©️console.log(String.raw`\u00A9`) // \u00A9</code></pre><h4 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h4><p>除了一些我们平时了解的一些方式，Symbol.for()方法可以创建相同的 symbol。</p><pre><code class="JavaScript">Symbol.for(&#39;foo&#39;) === Symbol.for(&#39;foo&#39;) // true</code></pre><p>Symbol.keyFor 可以查询注册表。其参数必须是 symbol 类型。等还有很多 Symbol 方式，就不介绍了</p><h4 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h4><p>每个 Object 实例都有以下属性和方法：</p><ul><li>constructor：用于创建当前对象的函数</li><li>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串或者符号</li><li>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型</li><li>propertyIsEnumerable(propertyName)：用来判断给定的属性是否可以使用</li><li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</li><li>toString()：返回对象的字符串表示</li><li>valueOd()：返回对象对应的字符串、数值或布尔值表示</li></ul><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>++以及–有前缀操作和后缀操作，前缀操作就是先执行++然后赋值，后缀操作是先赋值后++。对象则会调用 valueOf 的方法取得可以操作的值，如果是 NaN，调用 toString 并再次应用其他规则</p><p>Infinity 乘以 0 返回 NaN，取余操作 26%5 结果为 1，Infinity / Infinity 结果为 NaN。指数操作符<strong>，2</strong>3 结果为 8，当然你也可以 16**0.5</p><p>任何关系操作符在比较 NaN 的时候都返回 false，null == undefined 结果为 true，逗号操作符可以在一条语句中执行多个操作，如下 let num = (1, 2, 3, 4, 5) 最终 num 的值为 5</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>do-while 语句循环体内代码在退出前至少执行一次，而 while 语句先检测退出条件，在执行循环体内代码。而 for 循环语句将循环相关的代码进行了封装，如果 while 循环实现不了的逻辑，那么 for 也实现不了</p><pre><code class="JavaScript">// 创建一个无限循环for(;;){  dosomething()}</code></pre><p>for-in 语句是一种严格的迭代语句，枚举对象中的非符号键属性，for (property in expression) statement，for-in 语句不能保证返回对象属性的顺序</p><p>for-of 用于遍历可迭代对象的元素，按照可迭代对象的 next()方法产生值的顺序迭代，在此基础上还有 for-await-of 循环，对于嵌套循环语句来说，可以使用标签语句，对循环语句打上标签，然后可以通过 break 或者 continue 的语句进行引用</p><p>switch 在进行比较的时候都是全等的操作比较，不会强制转换数据类型</p><h2 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h2><p>引用值和原始值的区别，函数内部是局部变量，typeof 是用来判断一个变量是否为原始类型最为合适，检测函数的时候也会返回 function，不同浏览器对于 typeof RegExp 有差异，如果是 null 则返回 object，对于引用类型，可以使用 instanceof 操作符，可以判断 Object、Array、RegExp，当然[] instantceof Object 也返回 true</p><p>函数上参数被认为是当前上下文中的变量，遵循和函数内部变量访问相同的规则。当然 eval()调用的内部存在第三种上下文，除了全局上下文和函数上下文，某些语句可以在作用域链前端临时添加一个上下文，try/catch 语句的 catch 块，with 语句。</p><p>如果想让整个对象不允许修改，需要使用 Object.freeze(),虽然使用不会报错，但是静默失败，尽量都用 const 声明</p><p>定时垃圾回收，垃圾回收方式：标记清理，引用计数（循环引用存在问题），循环引用的处理可以把循环引用的内容设置为 null。垃圾回收的性能问题，当然一些浏览器中也可以主动触发垃圾回收。内存管理内存优化指的是保证程序在执行的时候只保存必要的数据，数据不必要要将其设置为 null，释放其引用，也叫解除引用。const 和 let 提升性能，隐藏类和删除操作，内存泄漏方面：全局变量、定时器、闭包。静态分配与对象池。JavaScript 的数组是大小可变的，变化的时候引擎会先删除之前的，在创建一个新的。静态分配优化是一种极端的形式，可不用考虑</p><h2 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul><li>Date.parse() 接受一个表示日期的字符串参数，可将这个字符串表示的日期转换成毫秒数。这个字符串可以为 8/19/2021，May 23, 2019，Tue May 23 2019 00:00:00 GMT-0700，如果要创建一个 2019 年 5 月 23 日的日期对象，可以使用 let someDate = new Date(Date.parse(“May 23, 2019”))，如果传入的并不能表示日期，则对应的返回 NaN，当然后台可自动的调用 Date.parse()，也就是 let someDate = new Date(“May 23, 2019”)和上面是等价的</li><li>Date.UTC()返回日期的毫秒表示，参数是年月日时分秒毫秒，年月必须，其余默认为 0（日默认为 1），月从 0 开始。如果创建一个 2000 年 1 月 1 日 0 点，则为 new Date(Date.UTC(2000, 0))，当然 Date.UTC 也会隐式调用，可以直接在 new Date 中使用</li><li>Date.now() 返回执行时刻的毫秒数</li><li>toLocaleString - “2021/8/19”</li><li>toString() - “Thu Aug 19 2021 14:39:24 GMT+0800 (中国标准时间)”</li><li>valueOf() - 返回的是数字类型的日期的毫秒数</li><li>toDateString() - “Thu Aug 19 2021”</li><li>toTimeString() - “14:43:06 GMT+0800 (中国标准时间)”</li><li>toLocaleDateString() - “2021/8/19”</li><li>toLocaleTimeString() - “下午 2:44:19”</li><li>toUTCString() - “Thu, 19 Aug 2021 06:44:54 GMT”</li></ul><p>以下的去处了 UTC 的一些方式，类似 getUTCFullYear，setUTCFullYear 等</p><ul><li>getTime() 返回日期的毫秒数，同 valueOf()</li><li>setTime() 设置日期的毫秒表示，从而修改整个日期</li><li>getFullYear() 返回 4 位数年数</li><li>setFullYear() 设置 4 位数年</li><li>getMonth()</li><li>setMonth()</li><li>getDate()</li><li>setDate()</li><li>getDay() 返回日期中表示周几（0 为周日，6 为周六）</li><li>getHours() 0-23 小时中的某一个</li><li>setHours()</li><li>getMinutes() 0-59 分钟数</li><li>setMinutes()</li><li>getSeconds()</li><li>setSeconds()</li><li>getMilliSeconds() 返回毫秒数</li><li>setMilliseconds()</li><li>getTimezoneOffset() 返回以分钟计的 UTC 与本地时区的偏移量</li></ul><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>创建正则表达式 let expression = /pattern/flags，也可以使用 new RegExp(pattern, flags)</p><p>pattern 表示正则表达式</p><p>flags 表示匹配模式的标记</p><ul><li>g 全局模式，查找全部内容，而不是找到一个就结束</li><li>i 不区分大小写</li><li>m 多行模式，表示查找到一行文本末尾时会继续查找</li><li>y 粘附模式，表示只查找从 lastIndex 开始以及之后的字符串</li><li>u 启用 Unicode 匹配</li><li>s dotAll 模式，表示元字符.匹配任何字符（包括\n 或者\r）</li></ul><p>上述对应的实例属性有以下，对应的是提供了有关模式的各方信息，表示当前这个正则表达式是否开启了某个模式 global、ignoreCase、unicode、sticky、lastIndex、multiline、dotAll、source、flags，下面是 RegExp 实例方法</p><ul><li>exec() 参数为对应的要匹配的字符串，如果找到了匹配项，返回包含第一个匹配信息的数组，没找到返回 null，返回的数组包含两个额外的属性，index 和 input，index 是字符串中匹配模式的起始位置，input 是要查找的字符串</li></ul><pre><code class="JavaScript">let text = &quot;mom and dad and baby&quot;;let pattern = /mom( and dad( and baby)?)?/gi;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // &quot;mom and dad and baby&quot;console.log(matches[0]); // &quot;mom and dad and baby&quot;console.log(matches[1]); // &quot; and dad and baby&quot;console.log(matches[2]); // &quot; and baby&quot;</code></pre><ul><li>test() 接收一个字符串参数，如果输入的文本与模式匹配，则返回 true，否则返回 false。捕获组可以通过 RegExp.$1 访问，依此类推</li></ul><h3 id="原始包装类型"><a href="#原始包装类型" class="headerlink" title="原始包装类型"></a>原始包装类型</h3><p>Number 重写了 valueOf 等方法，toString 可以接收一个参数，并返回相应基数形式的数值字符串</p><p>用于将数字格式转换成字符串格式的方法，整个数值范围是<code>-2**53到2**53-1</code></p><ul><li>toFixed() 要包含的小数位数，如果超过对应的位数则四舍五入</li><li>toExponential() 同 toFixed()一样，只不过结果用科学记数法表示</li><li>toPrecision() 接收一个参数，表示结果中数字的总位数</li><li>isInteger() 辨别一个数字是否为整数</li><li>isSafeInteger() 鉴别计算后的整数是否在安全范围内</li></ul><p>String 属性方法</p><ul><li>length 字符长度</li><li>charAt() 返回给定索引位置的字符</li><li>charCodeAt() 查看指定码元的字符编码</li><li>fromCharCode()</li><li>codePointAt() fromCodePoint()</li><li>normalize()</li></ul><p>不会修调用他们的字符串</p><ul><li>concat() 用于讲一个或多个字符拼接成一个新的字符</li><li>slice() 第一个参数开始位置，第二个结束位置，第二个参数省略表示到字符结尾</li><li>substr() 第一个参数开始位置，第二个参数表示返回的字符串数量，第二个参数省略表示到字符结尾</li><li>substring() 第一个参数开始位置，第二个结束位置，第二个参数省略表示到字符结尾</li><li>indexOf() 从头查找返回下标，第二个参数可选，表示开始搜索的位置</li><li>lastIndexOf() 从尾查找返回下标</li><li>trim() 创建一个字符串的副本，删除前后所有空格，trimLeft() trimRight() 从字符左侧还是右侧开始清理空格</li><li>repeat() 表示将某个字符重复多少次</li><li>padStart() padEnd() 填充字符串，第一个是填充后的长度，第二个参数是填充的内容，默认空格。如果指定长度小于当前字符长度，则返回原字符</li><li>可迭代字符<code>let iterator = &#39;abc&#39;[Symbol.iterator]()</code>，即可 iterator.next()</li><li>可通过 for of 进行遍历字符，当然你也可以方便的分割字符数组<code>[...&#39;abc&#39;]</code></li><li>toLowerCase()</li><li>toLocaleLowerCase()</li><li>toUpperCase()</li><li>toLocaleUpperCase()</li></ul><p>判断字符串中是否包含另一个字符串</p><ul><li>startsWith() 可选第二个参数表示开始位置</li><li>endsWith()</li><li>includes() 可选第二个参数表示开始位置</li><li>match() 接收一个参数，可以是正则表达式对象，也可以是正则表达式字符串。同正则对象的 exec()</li><li>search()</li><li>replace() 第一个参数可以是正则或者字符串，第二个参数为要替换的内容，也可以是一个函数</li><li>split() 第一个参数是以什么分割，可以是字符或正则，第二个参数是数组大小</li><li>localeCompare() 比较两个字符串，返回字母表顺序相关 -1 0 1</li></ul><h3 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h3><p>URL 编码方法，encodeURI 和 encodeURIComponent。</p><ul><li>encodeURI 用于整个 URI 进行编码，不会编码属于 url 的特殊字符，冒号，斜杠，问好，井号。对应的 decodeURI</li><li>encodeURIComponent 用于单独组件的编码，对应的 decodeURIComponent</li><li>eval</li></ul><p>Math 方法</p><ul><li><p>Math.E 自然对数的基数 e 的值</p></li><li><p>Math.LN10 10 为底的自然对数</p></li><li><p>Math.LN2 2 为底的自然对数</p></li><li><p>Math.LOG2E 以 2 为底 e 的对数</p></li><li><p>Math.LOG10E 以 10 为底 e 的对数</p></li><li><p>Math.PI π 的值</p></li><li><p>Math.SQRT1_2 1/2 的平方根</p></li><li><p>Math.SQRT2 2 的平方根</p></li><li><p>Math.max 一组数的最大值</p></li><li><p>Math.min 一组数的最小值</p></li><li><p>Math.ceil 始终向上舍入为最接近的整数</p></li><li><p>Math.floor 向下舍入为最接近的整数</p></li><li><p>Math.round 四舍五入</p></li><li><p>Math.found 返回数值最接近的单精度浮点值表示</p></li><li><p>Math.random 0-1 之间的随机数，包含 0 但不包含 1</p></li><li><p>Math.abs 绝对值</p></li><li><p>Math.exp E 的 x 次幂</p></li><li><p>Math.cos</p></li><li><p>Math.sin</p></li><li><p>Math.tan</p></li><li><p>…等</p></li></ul><h2 id="集合引用"><a href="#集合引用" class="headerlink" title="集合引用"></a>集合引用</h2><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>访问对应的变量可以使用.的方式，当然也可以使用中括号，区别就是中括号内部可以用变量</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>new Array()当中可以传入数字，表示设置的这个数组的初始化 length，你也可以传入要保存的元素</p><p>Array.form()参数为类数组对象，可任何迭代的结构，也可以对现有的数组进行浅复制。第二个参数可以为可选映射函数参数，第三个参数指定映射函数中 this 的值，当然重写的 this 在箭头函数中不适用。当然还有对应的 Array.of 可以把一组参数转换成数组</p><p>数组的空位为 undefined，map，forEach 等会跳过这个空位，所以一般空位要显性的设置为 undefined。join 则识空位为字符串，数组最多可以包含 4294967295 个元素</p><p>检测是否为数组，instanceof Array，isArray</p><p>数组返回迭代器方法：keys 索引、values 元素、entries 索引/值对迭代器。</p><p>批量复制方法：copyWithin，填充数组方法 fill，第二个参数为从哪个索引下标之后，比如 fill(7, 1, 3)表示用 7 填充索引大于等于 1 且小于 3 的元素</p><ul><li>toLocaleString</li><li>toString 返回数组每个值等效字符拼接逗号分隔的字符串</li><li>valueOf 返回数组本身</li></ul><p>如果数组中某一项是 null 或 undefined，则在返回的结果中会以空字符串表示</p><ul><li>push 接收任意数量参数，添加到数组末尾，返回新的数组长度</li><li>pop 删除数组最后一项 减少数组 length，返回被删除的项</li><li>shift 删除数组的第一项并返回，数组长度减 1</li><li>unshift 在数组开头添加任意多个值，返回新的数组长度</li><li>reverse 数组反向排列，返回调用数组的引用</li><li>sort 会将数组每一项都调用 String()进行排序，当然 sort 也可以接受一个函数。比较函数接受两个参数，如果第一个参数在前面返回负值，相等返回 0，第一个参数排在后面返回正值，返回调用数组的引用</li><li>concat 创建新数组并连接一些元素，可打平数组。是否打平数组可以使用特殊符号 Symbol.isConcatSpreadable，false 为不打平数组</li><li>slice 接收一个或者两个参数，返回元素开始索引和结束索引对应的所有元素，但是不包含结束索引对应元素，此操作不影响原数组</li><li>splice 删除：两个参数，删除的第一个元素的位置和要删除的数量，比如 splice(0, 2)就是删除数组的前两个元素。插入：传三个参数，开始位置、0 和要插入的元素，第三个元素可以更多。替换：开始位置、要替换的元素数量，和要插入的任意多元素。这个操作影响原数组</li><li>indexOf lastIndexOf includes 都接收两个参数，要查找的元素和一个可选的起始位置</li><li>find 和 findIndex 找到匹配项之后，永远不检查数组的最后一个元素</li></ul><p>这些方法都不改变调用它们的数组</p><ul><li>every 对数组每一项都运行传入的函数，如果每一项函数都为 true，则这个方法返回 true</li><li>filter 对每一项都运行传入的函数，函数返回 true 的项会组成新的数组返回</li><li>forEach 对数组每一项都运行传入的函数，没有返回值</li><li>map 对数组每一项都运行传入的函数，返回由每次函数调用结果组成的数组</li><li>some 对数组每一项都运行传入的函数，如果有一项返回 true，则这个方法返回 true</li></ul><p>归并方法</p><ul><li>reduce 和 reduceRight 迭代数组所有项，在此基础上构建一个最终返回值。两个参数，第一个是对每项都运行的归并函数，第二个是归并起点的初始值。归并函数有四个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。</li></ul><h3 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h3><p>ArrayBuffer 是一个普通的 JavaScript 构造函数，在内存中分配特定数量的字节空间。<code>const buf = new ArrayBuffer(16)</code>就是在内存中分配 16 字节，一经创建就不能再调整大小，可通过 slice 复制其部分或者全部到一个新的实例中。允许你读写 ArrayBuffer 的视图是 DataView，简单了解一下，看不懂</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 和 Object 类似，但是二者还是有一些细微的差别。</p><p>使用 new Map()可以创建一个空映射，想在创建的同时初始化实例，可以用键值对数组。初始化之后可以用 set 方法添加键值对，可以使用 get 和 has 进行查询，可以通过 size 获取键值对数量，使用 delete 和 clear 进行值删除，其键值可以为任意的数据类型。当使用 get 的时候，遵循 SameValueZero，</p><p>可以通过 entries 方法取得迭代器，使用 for of 进行遍历，可以使用扩展操作符转成数组的形式。也可以使用 forEach 进行遍历，keys 和 values 分别返回以插入顺序生成键值的迭代器</p><p>Object VS Map</p><ol><li>内存占用，Map 大约可以比 Object 多存储 50%的键值对</li><li>插入性能，Map 会稍微快一点，大量操作 Map 性能更好一点</li><li>查找速度，大型 Object 和 Map 查找性能差异极小，少量 Object 更快，涉及大量查找操作，Object 更好一点</li><li>删除性能，Map 的 delete 操作比插入和查找更快，Object 的 delete 操作饱受诟病</li></ol><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 中的键只能是 Object 或者继承 Object 类型，使用非对象设置会报错。初始化完成之后可以使用 set 添加，get 和 has 查询，delete 删除。引用类型在任何时候都有可能会被销毁，所以没有迭代的能力。之所以只能用对象作为键，保证只有通过健对象引用才能取得值</p><ol><li>闭包私有变量，拿不到若映射种的键，也就无法取得若映射中的值</li><li>DOM 节点元数据，使用 Map 会将引用内容逗留在内存中，WeakMap 则节点从 DOM 树中被删除之后，垃圾回收就可以立即释放内存</li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>在很多方面，Set 就是加强的 Map。可以使用 new Set 进行初始化，add 增加值，has 查询，size 取得元素数量，delete 和 clear 删除元素，内部元素不允许重复。用于数组去重，可通过 values 方法以及其别名方法 keys 进行迭代。当然其 values 和 keys 的元素都一样。也可以使用 forEach 或者 entries 进行迭代</p><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>值必须是对象或者继承自 Object 类型，弱弱的拿着，不属于正式的引用，不会阻止垃圾回收。不可迭代，因为值在任何时候都可能会被销毁</p><h3 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="headerlink" title="迭代与扩展操作"></a>迭代与扩展操作</h3><p>一些可以默认迭代的原生集合类型有：Array、定型数组、Map、Set 都可以进行顺序迭代，使用 for-of 循环</p><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h3><p>循环是迭代基础的基础，forEach 不知道迭代何时终止</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>可迭代对象，Iterator，实现 Iterable 也就是可迭代协议必须暴露一个属性作为默认迭代器，这个属性必须使用特殊的 Symbol.Iterator 作为键。 Number 和{}这两个没有默认迭代器属性。迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。</p><p>for-of 循环可以通过 break，continue，return，throw 提前退出</p><p>迭代器可以通过 return 方法进行退出，但是 return 并不会强制迭代器进入关闭状态，但是还是会调用自定义 return 方法</p><h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h3><p>形式是一个函数，函数名称前面加一个*号表示是一个生成器。箭头函数不能用来定义生成器，</p><pre><code class="JavaScript">function* generatorFn() {  yield &#39;foo&#39;  return &#39;baz&#39;}let generatorObject = generatorFn()console.log(generatorObject.next()) // { done: false, value: &#39;foo&#39; }console.log(generatorObject.next()) // { done: true, value: &#39;baz&#39; }</code></pre><p>上一次让生成器函数暂停的 yield 关键字会接收到传给 next 方法的第一个值，第一次调用 next 传入的值不会被使用，因为这一次调用是为了开始执行生成器函数。迭代器可以使用 for 循环进行遍历</p><p>可以使用星号增强 yield 的行为，使其能够迭代一个可迭代对象，从而一次产出一个值</p><pre><code class="JavaScript">// 等价的generatorFnfunction* generatorFn() {  for (const x of [1, 2, 3]){    yield x  }}function* generatorFn() {  yield* [1, 2, 3]}// 递归function* nTimes(n){    if(n &gt; 0){        yield* nTimes(n-1)        yield n-1    }}for(const i of nTimes(8)){console.log(i)} // 0 - 8// 随机双向图class Node {  constructor(id) {    this.id = id    this.neighbors = new Set()  }  connect(node) {    if(node !== this) {      this.neighbors.add(node)    }  }}class RandomGraph {  constructor(size) {    this.nodes = new Set()    // 创建节点    for(let i = 0; i &lt; size; i++) {      this.nodes.add(new Node(i))    }    // 随机连接节点    const threshold = 1/size    for(const x of this.nodes){      for(const y of this.nodes){        if(Math.random() &lt; threshold){          x.connect(y)        }      }    }  }  // 调试  print() {    for (const node of this.nodes){      const ids = [...node.neighbors].map(n =&gt; n.id).join(&#39;,&#39;)      console.log(`${node.id}: ${ids}`)    }  }  // 深度优先遍历  isConnected() {    const visitedNodes = new Set()    function* traverse(nodes) {      for(const node of nodes){        if(!visitedNodes.has(node)){          yield node          yield* traverse(node.neighbors)        }      }    }    // 取得集合中的第一个节点    const firstNode = this.nodes[Symbol.iterator]().next().value    // 使用递归生成器迭代每个节点    for(const node of traverse([firstNode])){      visitedNodes.add(node)    }    return visitedNode.size === this.nodes.size  }}const g = new RandomGraph(6)g.print()</code></pre><p>提前终止生成器，return 可以提前终止，throw 也可以</p><h2 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h2><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><p>Object.definePreperty 可以修改属性的默认属性，接受三个参数，要给其添加属性的对象，属性名称和描述符对象，最后一个参数描述对象的属性可以包含 configurable（是否可以删除并重新定义）enumerable（是否可以通过 for-in 循环返回）writable（属性值是否可以被修改）value（包含属性实际的值），访问器属性 get 方法以及 set 方法</p><p>Object.getOwnPropertyDescriptor 取得指定属性的属性描述符</p><p>Object.getOwnPropertyDescriptors()取得对象所有属性上的对应的属性描述符</p><p>Object.assign 将每个源对象可枚举和自有属性复制到目标对象，浅复制，赋值期间出错，终止并退出，之前已经赋值的不会回滚</p><p>Object.is 与===很像，判断 NaN</p><p>解构赋值，更改变量名，设置默认值等操作</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>可以解决创建多个类对象的问题，也就是通过函数创建一个对象，最后这个方法将对象 return 返回出来</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>没有显式的创建对象，属性和方法直接赋值给了 this，没有 return 一个对象出来，方法首字母大写。调用的时候使用 new 操作符，这种方式调用会执行以下操作</p><ol><li>在内存中创建一个对象</li><li>这个新对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的 prototype 属性</li><li>构造函数内部的 this 被赋值为这个新的对象</li><li>执行构造函数内部的代码，也就是给新对象添加对应的属性</li><li>如果构造函数返回非空对象，则返回该对象，否则返回刚才创建的对象</li></ol><p>构造函数也是函数</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>原型的本质</p><ol><li>理解原型，无论何时创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性，指向原型对象，默认情况下原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。也就是 Person.prototype.constructor 指向 Person。<code>Person.prototype.__proto__===Object.prototype Person.prototype.__proto__.constructor===Object Person.prototype.__proto__.__proto__ === null)</code></li><li>实例通过<code>__proto__</code>连接到原型对象，构造函数通过 prototype 连接到原型对象，实例与构造函数没有直接联系，与原型对象有直接联系。同一个构造函数的两个实例，共享同一个原型对象</li><li>原型对象可以调用 isPrototypeOf 进行检查，传入参数的<code>__proto__</code>指向调用它的对象时返回 true。Object.getPrototypeOf()返回参数的<code>__proto__</code>的值。还有一个 setPrototypeOf()的方法，可以向实例的私有特性写入一个新的值，重写对象的原型继承关系。Object.create()可以创建一个新的对象并为其指定原型</li><li>原型层级查找关系。hasOwnProperty()方法用于确定某个属性是在实例上还是原型对象上。在实例上返回 true，原型上返回 false</li><li>in 操作符，可以通过对象访问指定属性时返回 true，不论在原型还是在实例上。for-in 可以返回实例属性和原型属性。要获得实例属性可使用 Object.keys()，列出所有实例属性可以使用 Object.getOwnPropertyNames()。for-in 和 Object.keys 的枚举顺序不确定。Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的</li><li>迭代对象：Object.values() Object.entries()，前者返回对象值数组，后者返回健值对数组。这两个方法执行对象的浅复制</li><li>原生对象原型</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>通过原型继承多个引用类型的属性和方法。实例和原型之间构造一条原型链</p><ol><li>默认原型</li><li>原型与继承的关系 instanceof isPrototypeOf</li><li>原型方法覆盖</li><li>原型链问题（引用值共享问题、子类型在实例化时不能给父类型构造函数传参）</li></ol><h4 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h4><pre><code class="javascript">function SuperType() {  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}function SubType() {  // 继承 SuperType  SuperType.call(this);}let instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); // &quot;red,blue,green,black&quot;let instance2 = new SubType();console.log(instance2.colors); // &quot;red,blue,green&quot;</code></pre><p>问题：必须在构造函数中定义方法，函数不能重用。子类不能访问父类原型上定义的方法</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><h4 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h4><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类定义不能进行变量提升，类受块级作用域限制，关键字 class，其中 constructor 定义内部的构造函数</p><p>new 实例化的过程：</p><ol><li>内存中创建一个新对象</li><li>新对象内部的<code>proto</code>指针被赋值为构造函数的 prototype 的属性</li><li>this 指向这个新对象</li><li>执行构造函数内部代码，给新对象添加属性</li><li>如果构造函数返回非空对象，返回该对象，否则返回刚创建的对象</li></ol><p>访问器，可以 get，set，静态类方法 static，执行不特定于实例的操作，定义在类的本身上。</p><p>继承不仅可以继承类，也支持继承普通的构造函数。派生类的方法可以通过 super 关键字引用它们的原型。super 只能在派生类构造函数和静态方法中使用。不能单独引用 super 关键字。super 会调用父类构造函数，并将返回的实例赋值给 this。不能再 super 之前调用 this</p><p>抽象基类：实例化时检测 new.target 是不是抽象基类，阻止实例化</p><h2 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h2><h3 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h3><p>Proxy，两个参数缺一不可，第一个是目标对象，第二个是处理程序对象。所有捕获器都可以基于自己的参数重建原始操作，可以通过调用全局 Reflect 对象上的同名方法来进行重建。revocable 方法可以支持撤销代理对象与目标对象之间的关联。</p><ol><li>反射 API 与对象 API 2. 状态标记 3. 用一等函数替代操作符 4. 安全的应用函数</li></ol><p>代理可以套娃，代理捕获器与反射方法有以下：</p><ol><li>get，获取属性值被调用，对应的反射 API 为 Reflect.get()</li><li>set，设置属性值被调用，对应的反射 API 为 Reflect.set()</li><li>has，会在 in 操作符中被调用，对应的反射 API 为 Reflect.has()</li><li>defineProperty</li><li>getOwnPropertyDescriptor</li><li>deleteProperty，delete 操作符调用</li><li>ownKeys，Object.keys 调用</li><li>setProtorypeOf</li><li>isExtensible</li><li>preventExtensions</li><li>apply</li><li>construct，会在 new 操作符中调用</li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数创建可以通过函数表达式和函数声明方式，当然你也可以使用箭头函数和构造函数的形式，构造函数接受任意多个字符，最后一个字符会被当成函数体，之前的参数都是函数的参数</p><pre><code class="javascript">let sum = new Function(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;)// 不推荐，解释两次，第一次当成常规的ECMAScript代码，第二次是解释传给构造函数的字符串</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数不能使用arguments，super和new.target，也不能用作构造函数，箭头函数也没有prototype属性</p><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>所有函数对象都会暴露一个只读的name属性，其中包含函数的信息，函数没有名称会显示空字符串，如果是使用Function构造函数创造会被标识成anonymous</p><p>如果函数是一个获取函数，设置函数，或者使用bind实例化，那么标识符前会加上一个前缀，get/set/bound</p><h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><p>函数参数在内部会表现为一个数组的形式，数组或多或少都没啥问题，非箭头函数可以在函数内部访问arguments对象，取得传进来的每个参数值。它是一个类数组对象，可以使用中括号访问其中的元素，当然其也有length属性</p><pre><code class="javascript">function doAdd(num1, num2) {      arguments[1] = 10;      console.log(arguments[0] + num2);}// 传递一个参数不会赋值，传递两个参数赋值</code></pre><p>箭头函数不能使用arguments，但是可以包装函数提供给箭头函数</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>可以直接在参数上写等于便可以设置对应的默认值</p><p>修改命名参数也不会影响arguments对象</p><p>参数初始化顺序遵循暂时性死区，前面定义的参数不能引用后面定义的</p><h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>函数声明提升</p><h3 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h3><p>arguments对象有一个callee属性，是一个指向arguments对象所在函数的指针。也就是arguments.callee指向函数本身</p><p>this在普通函数中调用时才能确定，而箭头函数this的引用是定义箭头函数的上下文</p><p>caller引用的是调用当前函数的函数</p><p>检测函数是否使用了new关键字调用的new.target属性，正常调用返回undefined，如果是使用new关键字调用，new.target将引用被调用的构造函数</p><h3 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h3><p>length：保存函数定义的命名参数的个数<br>prototype：不可枚举，for-in不会返回这个属性</p><p>apply：第二个参数可以是Array的实例，也可以是arguments对象<br>call：第二个参数要逐个传递<br>bind：返回的是一个函数，参数为逐个传递</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>arguments.callee可以使用命名函数表达式</p><pre><code class="javascript">const factorial = function f(num) {      if (num &lt;= 1) {        return 1;      } else {        return num * f(num - 1);}};</code></pre><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>条件：</p><ol><li>代码在严格模式下执行</li><li>外部函数的返回值是对尾部调用函数的调用</li><li>尾调用函数返回后不需要执行额外的逻辑</li><li>尾调用函数不是引用外部函数作用域中自由变量的闭包</li></ol><pre><code class="javascript">&quot;use strict&quot;;// 基础框架 function fib(n) {  return fibImpl(0, 1, n);}// 执行递归function fibImpl(a, b, n) {  if (n === 0) {    return a  }  return fibImpl(b, a+b, n-1)}</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>整个作用域链问题</p><pre><code class="javascript">window.identity = &#39;The Window&#39;;    let object = {    identity: &#39;My Object&#39;, 9 getIdentity () {        return this.identity;    }};object.getIdentity(); // &#39;My Object&#39; 11 (object.getIdentity)(); // &#39;My Object&#39;(object.getIdentity = object.getIdentity)(); // &#39;The Window&#39; </code></pre><p>闭包产生的内存泄漏问题</p><h3 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h3><p>IIFE立即调用函数表达式，可以模拟块级作用域</p><p>for循环的问题</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><h2 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h2><p>Promise有三种状态，pedding、fulfilled/resolved、rejected。状态不可逆，每个状态都应该有对应的恰当行为。期约的状态私有，不能检测和内部修改</p><p>为了避免期约被卡在pedding状态，可以设置一段时间后期约变成rejected，resolve的参数只有一个，多余的会忽略，切幂等</p><p>Promise.reject抛出一个异步错误，不能通过try/catch捕获，非幂等，返回拒绝的理由，它们是同步对象，但是也是异步执行模式的媒介</p><p>.then的方法必须传递函数作为参数，否则会被静默忽略，第一个函数为resolve执行，第二个函数位reject执行，不传resolve的话规范第一个参数传null。.catch的逻辑实际和reject类似</p><p>.finally在Promise转换成resolve或reject的时候都调用，没有办法知道期约的状态</p><p>Promise.resolve(‘foo’)会立即执行，.then()中的内容会被推到微任务消息队列</p><pre><code class="javascript">// reduce实现compose函数function compose(...fns) {  return (x) =&gt; fns.reduce((promise, fn) =&gt; promise.then(fn), Promise.resolve(x))}</code></pre><p>Promise当前是没有办法取消的，但是可以自己包装一个取消的方法，当然也可以封装一个当前进度的方法</p><h3 id="异步函数async-await"><a href="#异步函数async-await" class="headerlink" title="异步函数async await"></a>异步函数async await</h3>]]></content>
      
      
      <categories>
          
          <category> 红宝书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红宝书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript手册</title>
      <link href="/2021/03/TypeScript%E6%89%8B%E5%86%8C/"/>
      <url>/2021/03/TypeScript%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在调用之前就应该确保你的所调用的方法是存在的</p><p>tsc TypeScript编译器，也就是类型检查器，使用npm i -g typescript进行安装，然后编写你对应ts文件，使用tsc file.ts进行编译你的ts文件。如果ts文件写的不规范，tsc则会在命令行上出现错误。使用tsc –noEmitOnError file.ts对错误进行防御</p><p>tsc –target es2015 file.ts可以将输出的代码转成为相应的指定版本的js。noImplicitAny，隐藏类型不推断any，strictNullChecks标志操作null和undefined更加明确</p><h2 id="日常类型"><a href="#日常类型" class="headerlink" title="日常类型"></a>日常类型</h2><p>string、number、boolean是我们平常用的比较多的内置类型，大写的String、Number、Boolean是一些特殊的内置类型将，虽然是合法的，但是大写的很少出现在自己的代码中，始终对类型使用小写的字符</p><p>数组，可以用<code>number[]</code>，<code>string[]</code>，还有一种<code>Array&lt;number&gt;</code>，表示相同的意思，这个是用泛型进行的对应数组说明。<code>T&lt;U&gt;</code></p><p>TS还有一个特殊的类型any，可以在不希望特定值引起任何类型检查错误的时候使用它，上下文类型，ts会自动判断当前所用的一些类型是从哪里来</p><pre><code class="TypeScript">let arr = [&#39;text1&#39;, &#39;text2&#39;]arr.forEach(item =&gt; {    console.log(item.toUpperCase())})// 如果调用的不是string的方法则会报错function fn(arg: {x: number; y: number; z?: number}){ // 分割可以用,或者;    console.log(arg.x + arg.y)}</code></pre><p>可选属性在属性名后面加一个？，如上面的z属性就是可选属性，对于可选属性来说，你必须先对其进行一个非undefined的判断然后再使用它</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>可以直接调用他们共有的属性，否则就得使用条件进行对应的判断</p><pre><code class="TypeScript">const strAndNum: string | number = 1;</code></pre><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>这两个之间可以自由选择，但是还是有一些对应的区别</p><pre><code class="TypeScript">type Point = {    x: number;    y: number;}interface Point = {    x: number;    y: number;}</code></pre><table><thead><tr><th align="left">type</th><th align="left">interface</th></tr></thead><tbody><tr><td align="left">扩展类型通过&amp;</td><td align="left">扩展类型通过extends</td></tr><tr><td align="left">向现有见面增加字段</td><td align="left">创建后无法改变类型</td></tr><tr><td align="left">不参与声明合并 ｜ 可以声明合并 ｜</td><td align="left"></td></tr><tr><td align="left">可以命名基元 ｜ 只能用于声明对象的形状，不能重命名基元 ｜</td><td align="left"></td></tr></tbody></table><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>如果你要使用document.getElementById()，ts仅知道其返回对应的HTMLElement，但是你知道你页面会一直存在对应的element，此时你就可以使用类型断言</p><pre><code class="TypeScript">// 可以使用类型断言来指定具体的类型const myCanvas = document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;// 其中在tsx中你可以这样写const myCanvas = &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;);// 当然你还可以这样const x = &quot;hello&quot; as unknown as number;const a = (expr as any) as T;</code></pre><h3 id="文字类型"><a href="#文字类型" class="headerlink" title="文字类型"></a>文字类型</h3><pre><code class="TypeScript">// 可以使用文字类型来接受一组你想要的值function printText(s: string, align: &#39;left&#39; | &#39;right&#39; | &#39;center&#39;){}printText(&#39;hi&#39;, &#39;center&#39;)</code></pre><p>数值类型类似，当然其可以与其它类型相互结合使用</p><h3 id="字面推论"><a href="#字面推论" class="headerlink" title="字面推论"></a>字面推论</h3><pre><code class="TypeScript">const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; };handleRequest(req.url, req.method);// 如果说handleRequest第二个参数只接受GET或者POST那么上述代码是有问题的，因为req自动推断出method为字符串，但是handleRequest第二个参数只能是GET字符或者POST字符，则这样推断有问题，那么如何解决这个问题呢？// 1const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; };// 2handleRequest(req.url, req.method as &quot;GET&quot;);// 3 可以使用as const，将req变成文字类型const req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; } as const;</code></pre><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><p>表示缺少或者未初始化的值，strictNullChecks建议开启，用来确保在调用某些方法之前测试这些值的存在</p><pre><code class="TypeScript">function doSomething(x: string | undefined) {  if (x === undefined) {    // do nothing  } else {    console.log(&quot;Hello, &quot; + x.toUpperCase());  }}</code></pre><h3 id="非空断言运算符（-）"><a href="#非空断言运算符（-）" class="headerlink" title="非空断言运算符（!）"></a>非空断言运算符（!）</h3><p>用于从类型中删除null和undefined不进行任何显式检查，实际上是一个类型断言，表明该值不是null或者undefined</p><pre><code class="TypeScript">function liveDangerously(x?: number | undefined) {  // No error  console.log(x!.toFixed());}</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>之后进行一个对应的填充</p><h3 id="不常见的基元"><a href="#不常见的基元" class="headerlink" title="不常见的基元"></a>不常见的基元</h3><p>bigint symbol</p><h2 id="Narrowing"><a href="#Narrowing" class="headerlink" title="Narrowing"></a>Narrowing</h2><p>在TS中，我们需要检验当前传进来的数据的各种情况，才能够缩小类型以便TS能够正常的解析。检查一些值的操作用到最多的就是typeof，但是一定要注意typeof null返回的是’object’字符，以下实例就是一个很好的说明</p><p>TS会自动缩小特定分支范围</p><pre><code class="TypeScript">function printAll(strs: string | string[] | null) {  if (typeof strs === &quot;object&quot;) {    for (const s of strs) {      // Object is possibly &#39;null&#39;.      console.log(s);    }  } else if (typeof strs === &quot;string&quot;) {    console.log(strs);  } else {    // do nothing  }}</code></pre><p>当然上述代码可以通过strs &amp;&amp; typeof strs === ‘object’来确定，也可以提前通过if来判断strs是否存在</p><pre><code class="TypeScript">interface Container {  value: number | null | undefined;}function multiplyValue(container: Container, factor: number) {  // Remove both &#39;null&#39; and &#39;undefined&#39; from the type. 所以其不会报错  if (container.value != null) {    console.log(container.value);//                        ^ = (property) Container.value: number    // Now we can safely multiply &#39;container.value&#39;.    container.value *= factor;  }}</code></pre><h3 id="类型谓词"><a href="#类型谓词" class="headerlink" title="类型谓词"></a>类型谓词</h3><pre><code class="TypeScript">function isFish(pet: Fish | Bird): pet is Fish{  return (pet as Fish).swim !== undefined}const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];const underWater1: Fish[] = zoo.filter(isFish);// or, equivalentlyconst underWater2: Fish[] = zoo.filter(isFish) as Fish[];// The predicate may need repeating for more complex examplesconst underWater3: Fish[] = zoo.filter((pet): pet is Fish =&gt; {  if (pet.name === &quot;sharkey&quot;) return false;  return isFish(pet);});</code></pre><p>pet is Fish相当于我们手动指定了当前的类型</p><h3 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h3><p>在缩小范围的过程中，可以将并集缩小到所有可能性一无所有的程度，这种情况下，将使用never类型来表示不应该存在的状态</p><p>never类型可以分配给每种类型，但是，没有类型可以分配给never类型（自身除外）。</p><h2 id="函数更多相关信息"><a href="#函数更多相关信息" class="headerlink" title="函数更多相关信息"></a>函数更多相关信息</h2><h3 id="函数类型表达式"><a href="#函数类型表达式" class="headerlink" title="函数类型表达式"></a>函数类型表达式</h3><pre><code class="TypeScript">function greeter(fn: (a: string) =&gt; void){  // 也可以用类型别名来命名函数类型  // type GreetFunction = (a: string) =&gt; void  fn(&#39;hello&#39;)}function printToConsole(s: string) {  console.log(s)}greeter(printToConsole)</code></pre><p>函数除了可以调用意外还具有属性，如何声明一个具有属性的函数？</p><pre><code class="TypeScript">type DescribableFunction = {  description: string;  (someArg: number): boolean;}function doSomeThing(fn: DescribableFunction) {  console.log(fn.description + &#39;required&#39; + fn(6))}</code></pre><h3 id="构造签名"><a href="#构造签名" class="headerlink" title="构造签名"></a>构造签名</h3><p>构造函数的声明方式</p><pre><code class="TypeScript">type SomeConstructor = {  new (s: string): SomeObject;}function fn(ctor: SomeConstructor) {  return new ctor(&#39;hello&#39;)}// 可以任意组合相同类型的调用签名和构造签名interface CallOrConstruct {  new (s: string): Date;  (n?: number): number;}</code></pre><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>如果我们要描述两个值对应之间的关系的时候，要使用泛型，TS可以自动推断出一些类型</p><pre><code class="TypeScript">function firstElement&lt;Type&gt;(arr: Type[]): Type {  return arr[0]}// 指定参数类型function combine&lt;Type&gt;(arr1: Type[], arr2: Type[]): Type[] {  return arr1.concat(arr2)}// 这样写有问题const arr = combine([1,2], [&#39;hello&#39;])// 这样写OKconst arr = combine&lt;string | number&gt;([1,2], [&#39;hello&#39;])</code></pre><p>泛型都是关于将两个或者多个具有相同类型的值进行的关联，要尽可能使用类型参数本身，而不要限制它。如果类型参数仅出现在一个位置，则应当考虑我们是否实际需要它</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><pre><code class="TypeScript">function firstElement(arr?: string) {  // ....}</code></pre><p>为回调编写函数类型时，切勿编写可选参数，除非你打算在不传递该参数的情况下调用该函数</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><pre><code class="TypeScript">function len(s: string): number;function len(arr: any[]): number;function len(x: any) {  return x.length}len(&#39;&#39;) // OKlen([0]) // OKlen(Math.random() &gt; 0.5 ? &#39;hello&#39; : [0]) // fail 不能使用可能是字符串或数组的值来调用它</code></pre><h3 id="其它类型"><a href="#其它类型" class="headerlink" title="其它类型"></a>其它类型</h3><ul><li>this相关</li><li>void表示不返值的函数的返回值，但是如果type vf = () =&gt; void这种函数类型可以返回任何值，但是它将被忽略</li><li>object表示不是原始值的任何值，不同于空对象类型，极有可能永远也用不上</li><li>unknown表示任何值，与any类似，但是更安全，unknown做任何事情都是不合法的，可以描述一个返回值未知类型的函数</li><li>never某些函数从不返回值，比如一些error的函数，确定没有任何东西的时候也会出现</li><li>Function，所有函数的值相等，可以用() =&gt; void代替</li><li>剩余参数，<code>...m: number[]</code></li><li>注意TS一般认为数组是可变的，所以在用扩展运算符给一个函数传递参数的时候会发生意想不到的效果，使用as const表达数组的不可变性</li><li>解构参数类型<code>function ({a, b, c}: {a: number; b: number; c: number}){}</code></li></ul><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>上述我们可知道定义对象属性可通过type以及interface关键字对对象进行描述</p><h3 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h3><ul><li>可选属性可以在对象属性key值后面添加?表示可选，可以给未指定的值设置默认值</li><li>readonly只读</li></ul><pre><code class="TypeScript">interface PaintOptions {  shape: Shape;  xPos?: number;  yPos?: number;}function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions)</code></pre><h3 id="扩展类型"><a href="#扩展类型" class="headerlink" title="扩展类型"></a>扩展类型</h3><p>关键字extends可以使我们可以有效的复制其他命名类型的成员，并添加我们所需要的任何新的成员，并且extends可以从多种类型进行扩展<code>interface ColorfulCircle extends Colorful, Circle {}</code></p><h3 id="交叉点类型"><a href="#交叉点类型" class="headerlink" title="交叉点类型"></a>交叉点类型</h3><p>关键字&amp;，用于结合现有的对象类型<code>type ColorfulCircle = Colorful &amp; Circle;</code>，ColorfulCircle表示其具有Colorful和Circle的所有成员</p><h3 id="通用对象类型"><a href="#通用对象类型" class="headerlink" title="通用对象类型"></a>通用对象类型</h3><p>使用泛型来声明一个type参数</p><pre><code class="TypeScript">interface Box&lt;Type&gt; {  contents: Type;}type Box&lt;Type&gt; = {  contents: Type}type OrNull&lt;Type&gt; = Type | null;type OneOrMany&lt;Type&gt; = Type | Type[];type OneOrManyOrNull&lt;Type&gt; = OrNull&lt;OneOrMany&lt;Type&gt;&gt;;//   ^ = type OneOrManyOrNull&lt;Type&gt; = OneOrMany&lt;Type&gt; | nulltype OneOrManyOrNullStrings = OneOrManyOrNull&lt;string&gt;;//   ^ = type OneOrManyOrNullStrings = OneOrMany&lt;string&gt; | nullfunction getProperty&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key) {  return obj[key];}</code></pre><p>ReadonlyArray是一种特殊类型，描述不应该被改变的数组，也可以简写<code>readyonly string[]</code></p><h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><pre><code class="TypeScript">type StringNumberPair = [string, number, number?]type StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];</code></pre><h2 id="Keyof类型运算符"><a href="#Keyof类型运算符" class="headerlink" title="Keyof类型运算符"></a>Keyof类型运算符</h2><p>作用于对象</p><pre><code class="TypeScript">type Mapish = { [k: string]: boolean };type M = keyof Mapish;//   ^ = type M = string | number</code></pre><p>对象的key值始终被强制转换成字符串，因此<code>obj[0]</code>与<code>obj[&#39;0&#39;]</code>始终相同</p><p>ts中也有一个typeof关键字，作用就是找到当前一些内容的ts类型</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2>]]></content>
      
      
      <categories>
          
          <category> 教程 笔记 TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学会管理，成为会带团队的技术人</title>
      <link href="/2021/02/%E5%AD%A6%E4%BC%9A%E7%AE%A1%E7%90%86%EF%BC%8C%E6%88%90%E4%B8%BA%E4%BC%9A%E5%B8%A6%E5%9B%A2%E9%98%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BA%BA/"/>
      <url>/2021/02/%E5%AD%A6%E4%BC%9A%E7%AE%A1%E7%90%86%EF%BC%8C%E6%88%90%E4%B8%BA%E4%BC%9A%E5%B8%A6%E5%9B%A2%E9%98%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇词"><a href="#开篇词" class="headerlink" title="开篇词"></a>开篇词</h2><p>技术人三要素：稳定性，债务，架构，技术管理要求是先技术，后管理。有哪些东西是作为技术leader必须要做好的本职工作，建立好自己的管理认知以及体系</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><h3 id="如何应对事故并做好复盘"><a href="#如何应对事故并做好复盘" class="headerlink" title="如何应对事故并做好复盘"></a>如何应对事故并做好复盘</h3><p>82原则：20%人员能力和机制流程的欠缺，80%人员的稳定性意识不足，并且故障应对方法不当</p><p>稳定性KPI，事故类型，事故前预防，事故中应急，事故后复盘，总结经验</p><p>可用性事故，资损类事故，有条不紊的安排学生进行排障，确定信息沟通的秩序，结合信息做好线上同步</p><p>1-5-10标准，1分钟发现，5分钟响应，10分钟恢复，故障处理的核心在于快</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-2-21/1613898029719-iShot2021-02-21%2016.58.43.png" alt="故障处理的生命周期"></p><p>发现异常，直接锁定+排除，比如刚发布了一个新功能，导致QPS下降，基本就可以断定是刚才发布的问题。当出现问题的时候，可能会有很多干扰因素，很难直接锁定，我们自己本身要做的就是结合业务场景，让链路上的所有关联方自查自证，通过排除法锁定故障，常见的应急三板斧，变更回滚，服务重启，降级&amp;限流，注意紧急变更会不会引起新的风险</p><ol><li>处理动作尽量简单，最好立竿见影</li><li>线上修复问题最忌讳因为赶时间就忽略关键测试，验证步骤，造成二次上线问题</li><li>除了修复系统的增量问题，故障数据也要处理，完全修复业务上的影响</li></ol><p>如何有价值的做好事后的复盘：复盘的核心不是为了追责&amp;甩锅，要最大程度的去榨干事故的剩余价值，通过全盘的思考与总结，来看看系统设计，流程机制，应急处理，人员安排等各方面有哪些不足，哪些可以提升的地方，哪些问题是共性的，需要在各个团队进行大扫除，一次学费，受益终身。</p><p>事故时长，事故根因，事故改进措施，事后复盘的时候，要详细介绍事故如何发生，如何处理，未来如何预防。如何带领团队把精力放在改进措施的落实以及事故前治理上，更有价值，需要留出时间让团队小伙伴进行内部review，避免为了开会而复盘</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-2-21/1613899520971-iShot2021-02-21%2017.25.07.png" alt="稳定性总结"></p><h3 id="可用性治理的三个关键要点"><a href="#可用性治理的三个关键要点" class="headerlink" title="可用性治理的三个关键要点"></a>可用性治理的三个关键要点</h3><p>架构设计，编码，测试，上线。变更会引起90%以上的故障，小步快走，高速迭代。可监控，可回滚，可灰度。变更需要监控，完善的监控告警比人工反馈响应更快。要监控的内容：</p><ol><li>是否有问题发生</li><li>哪里发生了问题</li><li>发生了什么问题</li></ol><p>灰度就是为了对抗一些不确定性，并不是小范围测试，回滚就是变更的后悔药</p><p>验证演练预案设计，制造可控的故障</p><p>新人从稳定性学习开始，承诺一致性原则，学习最近半年的一个真实事故，并总结邮件给部门所有人</p><h3 id="那些年源源不断的红包事故"><a href="#那些年源源不断的红包事故" class="headerlink" title="那些年源源不断的红包事故"></a>那些年源源不断的红包事故</h3><p>平台感知能力弱，技术指标不敏感，持续时间长，资金损失大，问题难以第一时间恢复，止损后引起舆论事件和公关事件，感知难，修复慢，影响大</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-2-21/1613901734165-iShot2021-02-21%2018.02.03.png" alt="资损定义"></p><ol><li>防：人为配置，发放阶段，核销阶段，退回阶段。资金流，资金账户，资金计算，资金凭据</li><li>监：一致性与正确性双核对，业务监控，组合观察业务指标</li><li>控：资金拦截+资产控制。问题止血不新增，控制资金流出，存量数据订正</li></ol><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-2-21/1613902127440-iShot2021-02-21%2018.08.11.png" alt="资损防控的关键"></p><h2 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h2><p>技术债务是否已知，因为能力不足根本没有意识到债务的产生与积累，因为交付压力进而在技术方案与实现上妥协形成的已知的技术债务</p><p>主要以下几点：</p><ol><li>开发者编写了低质量或者有潜在风险的代码</li><li>对于系统的实现和运行不了解，重复代码被大量的构造，缺少抽象与沉淀</li><li>缺少完善的开发机制和流程把控，比如测试，文档等方面做的不到位</li></ol><p>交付压力导致技术妥协，导致迭代成本增加，没人能够清晰的讲明白现在的实现逻辑，隐藏bug风险性很大，居高不下，系统的扩展性以及系统迭代很困难，最终导致延期，恶性循环导致人员流失，旧系统问题很大却又没有很好的方式，沉重的技术债务，开发难度越来越大</p><h3 id="如何带领团队从困境中突围"><a href="#如何带领团队从困境中突围" class="headerlink" title="如何带领团队从困境中突围"></a>如何带领团队从困境中突围</h3><p>解决方式：</p><ol><li>债务的Owner是技术leader，交付压力与技术债务的平衡，内外双修，增加减少债务的机会</li><li>checklist识别债务，从看不到的技术债务到list，轻重缓急的区分，分期偿还技术债务，要逐渐减少</li><li>存在即合理，动态变化才是王道，逐渐减少。技术妥协换取更早的上线，在业务的发展中寻找平衡，适当的债务以及要适当的还款</li></ol><h2 id="大项目"><a href="#大项目" class="headerlink" title="大项目"></a>大项目</h2><p>一号工程（老板项目），技改项目（核心系统重写），倒排期的重大业务</p><p>跨部门沟通难，开会回报进度比写代码的时间还多，项目倒排期，开发资源压缩，结果评判标准不同，看最终业务目标</p><p>重构除了解决以前的问题，还要预防之后的问题，越是重大的项目，越要准备充足</p><h3 id="把握关键点，谋定而后动"><a href="#把握关键点，谋定而后动" class="headerlink" title="把握关键点，谋定而后动"></a>把握关键点，谋定而后动</h3><p>项目为什么要这么做，项目要做成什么样，哪些人要来做，项目启动之后要怎么做，每部分要有负责人，各部分周期越短越好，可验证，立项会议</p><ol><li>缺兵少将，以项目的价值与收益为本金，借助上级组织的力量从其它团队借人。从更大的范围找人，项目交付并不等于结束</li><li>推不动的是人还是事。搞明白冲突现象下的利益诉求，为项目结果适当妥协，拖过项目地位和决策机制推动项目</li><li>一定会有项目变更，项目演进过程中识别出之前未考虑到的点。优先级排期，加班，统一变更统一管理，多汇报，了解当前的风险点</li></ol><p>驾驭大项目，人的问题要多余技术问题，按时上线，更关键的是业务效果以及对应的业务结果</p><h2 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h2><p>大项目管理，结构设计以及对应的业务场景来进行对应的设计，理解业务这件事</p><h3 id="深入业务"><a href="#深入业务" class="headerlink" title="深入业务"></a>深入业务</h3><p>产品需求不等于业务诉求，理解业务需求，整个业务流程：用户真实需求-&gt;业务-&gt;运营-&gt;产品-&gt;技术，中间经过了不断的加工处理以及拆分，要搞清楚源头。不能成为工具人，要明白自己的团队要干啥，但是不仅仅局限于团队干啥。</p><p>要清楚业务的现状，推测业务的发展，思考业务上对应的诉求，深度理解业务要成为前提，提升技术团队的使命感，实际体验客诉，并通过自己写的代码解决让客服&amp;用户头疼的问题，体现自己的价值，你会发现你是在帮助他人解决问题而不仅仅只是写代码。</p><p>如何理解业务：</p><ol><li>不要盲信产品，永远不要试图用战术上的勤奋，去掩盖你战略上的懒惰</li><li>从业务方接受需求描述说明-简单加工成PRD-根据业务方嗓门大小进行优先级排序-直接输出给技术，要学会独立思考，深入理解业务要解决什么问题，需要什么效果或者什么作用，严格把控那些伪需求和无价值需求，防止他们侵占团队的技术资源，防止PM成为传话筒</li><li>代入用户视角，实际体验一下，建立走进业务的机制，代入感，不要一次性作秀</li><li>分享业务对应的流程，借助数据变化，了解深入，业务与编码同样重要</li></ol><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-2-21/1613904724334-iShot2021-02-21%2018.51.51.png" alt="深刻理解业务"></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>架构工作的核心关注点，功能实现，性能优化，稳定性。接手历史系统，处理问题，结构性上没有设计好。重构系统，高扩展</p><ol><li>理解成本高</li><li>变更牵连多</li><li>一张图装不下</li><li>加人也无法解决问题，复杂度高，迭代压力大，稳定性频发</li></ol><h3 id="治理好系统复杂度才最务实"><a href="#治理好系统复杂度才最务实" class="headerlink" title="治理好系统复杂度才最务实"></a>治理好系统复杂度才最务实</h3><p>高内聚，低耦合，去掉不必要的复杂，分治，拆分到可解决的粒度，没有什么问题是拆模块解决不了的，如果有，就再拆一层，要适当的拆分，垂直拆分：把差异明确可以独立迭代的业务拆分开。水平拆分：把共性的能力下沉隔离。拆分与合并不决定</p><ol><li>更重注设计，对于coding来说</li><li>永远做2套以上的方案</li><li>从mvp的视角考虑设计，先做减法再做加法</li><li>关注上下游的实现</li><li>坚持日拱一卒，尽可能在每次迭代的过程中修复一个小问题</li><li>通过技术的建设让技术走在业务前面</li></ol>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS程序员的TypeScript（简单版）</title>
      <link href="/2021/01/TypeScript%E6%95%99%E7%A8%8B-%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/01/TypeScript%E6%95%99%E7%A8%8B-%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>关于TS是什么以及为什么要用它就不做赘述了，直接正片开始！</p><h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>TypeScript和JavaScript有着不同寻常的关系，JavaScript上的所有的功能，在TypeScript上都有，当然，TypeScript还多了一层类型校验。</p><p>就好比JavaScript中的原始类型像string、number或者object，但是它不会检查你是否是从一而终，比如定义了一个变量<code>let a = 1</code>，当你再写<code>a = true</code>的时候，也是没有任何问题，毕竟JavaScript是若类型语言。</p><p>当有了这种类型检查，那么你在代码中的一些简单的错误就不会再犯，就好比你的类型是数字但是却调用了字符串的方法。当然也会存在更友好的提示，再也不用担心你写错单词了。</p><p>下面就对TypeScript一些内容做一个简要的梳理</p><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>TypeScript在大多数的情况下对你写的代码是有一个类型推断的，比如你声明了一个变量并且给它分配了一个特定的值，那么TypeScript就会使用这个值的类型作为这个变量的默认类型</p><pre><code class="JavaScript">let TypeScript = &#39;FE情报局&#39;// let TypeScript: string</code></pre><p>通过了解JavaScript的工作原理，TypeScript可以建立起一个类型系统，它可以接受你的JavaScript代码，但是在这个基础上它已经有了自己的类型。并且无需添加额外的代码，因此这就是上述的例子中<code>TypeScript</code>为何知道自己的类型就是<code>string</code></p><p>作为一名前端，相信80%的人都在使用vs code，使用这个软件，在写TypeScript时候会让你更得心应手</p><h2 id="定义Types"><a href="#定义Types" class="headerlink" title="定义Types"></a>定义Types</h2><p>在JavaScript中我们可以使用多种设计模式，但是，一些设计模式会让自动的类型推断变的很困难，比如一些动态编程的模式。如果需要涵盖这些情况，TypeScript在JavaScript的基础上做了一些扩展，你可以告诉TypeScript这个地方应该是什么类型</p><p>例如，你创建了一个对象，包含<code>name: string</code>和<code>id: number</code>两个字断，你可以这样写：</p><pre><code class="JavaScript">const user = {    name: &#39;FE情报局&#39;,    id: 0}</code></pre><p>你可以使用<code>interface</code>来很明确的描述这个对象：</p><pre><code class="JavaScript">interface User {    name: string;    id: number;}</code></pre><p>然后你可以使用你新创建的<code>interface</code>，用<code>: TypeName</code>这种形式来声明你的对象内部类型结构</p><pre><code class="JavaScript">const user: User = {    name: &#39;FE情报局&#39;,    id: 0}</code></pre><p>如果如果你的对象不能够匹配你所提供的<code>interface</code>，TypeScript会报出对应的错误</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-1-28/1611828689572-iShot2021-01-28%2018.07.42.png" alt="interface错误"></p><p>自从JavaScript支持<code>class</code>关键字和面向对象编程，作为TypeScript，你可以对类使用<code>interface</code>进行类型声明</p><pre><code class="JavaScript">interface User {    name: string;    id: number;}class UserAccount {    name: string;    id: number;        constructor(name: string, id: number) {        this.name = name;        this.id = id;    }}const user: User = new UserAccount(&#39;FE情报局&#39;, 1)</code></pre><p>还可以使用<code>interface</code>来声明函数的参数以及函数的返回值</p><pre><code class="JavaScript">function getAdminUser(): User {    // ...}function deleteUser(user: User){    //...}</code></pre><p>JavaScript中已经有一部分的原始类型你可以在<code>interface</code>中使用：<code>boolean bigint null number string symbol object undefined</code>。TypeScript在这基础上还扩展了一些，比如<code>any</code>（允许任何内容），<code>unknown</code>（确保使用该类型的人声明该类型是什么），<code>never</code>（这个类型不可能发生）<code>void</code>（函数return undefined或者没有返回值的时候）</p><p>你将会看到有两种声明类型的方式：<code>Interfaces</code> <code>Types</code>，你应该更倾向于<code>interfaces</code>，当你需要特定功能的时候使用<code>type</code></p><h2 id="组合类型Types"><a href="#组合类型Types" class="headerlink" title="组合类型Types"></a>组合类型Types</h2><p>在TypeScript中，你可以在基本类型的基础上创建一个混合类型。有两种常用的方式：联合类型和泛型</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>关于联合类型，你可以声明一种类型是多种类型中的一个。例如，你可以将一个<code>boolean</code>类型描述为<code>true</code>或者<code>false</code></p><pre><code class="JavaScript">type MyBool = true | false</code></pre><blockquote><p>在你本地测试这段代码的时候，将鼠标放上去，你会发现他的类型是<code>boolean</code>，这个是结构类型系统的属性</p></blockquote><p>联合类型一个比较流行的事例是描述字符串或者数字的一个集合</p><pre><code class="JavaScript">type WindowStates = &#39;open&#39; | &#39;closed&#39; | &#39;minimized&#39;type LockStates = &#39;locked&#39; | &#39;unlocked&#39;type Numbers = 1 | 3 | 5 | 7 | 9</code></pre><p>联合类型提供了一种不同于<code>types</code>的方法，例如，你在函数的参数中可以将其类型定为<code>array | string</code></p><pre><code class="JavaScript">function getLength(obj: string | string[]): number{    return obj.length}</code></pre><p>你还可以在方法中根据不同的传参类型来返回不同的数据</p><pre><code class="JavaScript">function wrapInArray(obj: string | string[]){    if (typeof obj === &#39;string&#39;){        return [obj]    } else {        return obj    }}</code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型为类型提供变量。一个常见的例子是数组，没有泛型的数组可以包含任何类型，一个由泛型定义的数组可以通过泛型来描述数组内的内容</p><pre><code class="JavaScript">type StringArray = Array&lt;string&gt;type NumberArray = Array&lt;number&gt;type ObjectWithNameArray = Array&lt;{ name: string }&gt;</code></pre><p>你还可以声明你自己使用泛型的类型</p><pre><code class="JavaScript">interface Backpack&lt;Type&gt; {    add: (obj: Type) = void;    get: () =&gt; Type}// 这一行是为了告诉TypeScript有一个常量名字叫backpackdeclare const backpack: Backpack&lt;string&gt;// object是字符串类型，因为我们定义了以上的可变部分const object = backpack.get()// 当backpack的add方法参数规定为字符串的时候，你不能够使用number，会引发对应的错误警告// backpack.add(23) ⚠️</code></pre><h2 id="结构类型系统"><a href="#结构类型系统" class="headerlink" title="结构类型系统"></a>结构类型系统</h2><p>一个TypeScript的核心原则是重点检查值的结构。也可以称为<code>duck typing</code>或者<code>structural typing</code></p><p>在结构类型的系统中，如果两个对象拥有共同的结构，他们可以被定义为同一种类型</p><pre><code class="JavaScript">interface Point {    x: number;    y: number;}function logPoint(p: Point) {    console.log(`${p.x}, ${p.y}`)}const point = {x: 12, y: 26}logPonit(point)</code></pre><p>point变量永远不会声明为Point类型，但是，TypeScript在类型检查中会将point与Point的结构进行比较，他们有相同的结构，所以代码是OK的</p><p>结构匹配只需要同要匹配的结构的子集匹配即可</p><pre><code class="JavaScript">const point3 = {x: 12, y: 26, z: 89}logPoint(point3) //OKconst rect = {x: 33, y: 3, width: 100, height: 200}logPoint(rect) //OKconst color = {hex: &#39;#000&#39;}logPoint(color) //fail</code></pre><p>类和对象匹配的格式没有区别</p><pre><code class="JavaScript">class VirtualPoint {    x: number;    y: number;    constructor(x: number, y: number) {        this.x = x        this.y = y    }}const newVPoint = new VirtualPoint(13, 56)logPoint(newVPoint) // logs &quot;13, 56&quot;</code></pre><p>如果对象或类具有所有必须的属性，则TypeScript会认为它们匹配</p>]]></content>
      
      
      <categories>
          
          <category> 教程 笔记 TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未来cookie获取和更新再不用自己去封装了！</title>
      <link href="/2020/12/%E6%9C%AA%E6%9D%A5cookie%E8%8E%B7%E5%8F%96%E5%92%8C%E6%9B%B4%E6%96%B0%E5%86%8D%E4%B8%8D%E7%94%A8%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%B0%81%E8%A3%85%E4%BA%86%EF%BC%81/"/>
      <url>/2020/12/%E6%9C%AA%E6%9D%A5cookie%E8%8E%B7%E5%8F%96%E5%92%8C%E6%9B%B4%E6%96%B0%E5%86%8D%E4%B8%8D%E7%94%A8%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%B0%81%E8%A3%85%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h2 id="谷歌浏览器87版本更新"><a href="#谷歌浏览器87版本更新" class="headerlink" title="谷歌浏览器87版本更新"></a>谷歌浏览器87版本更新</h2><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2020-12-31/1609407871306-Chrome-version.png" alt="谷歌浏览器版本"></p><p>谷歌浏览器的最新版本在2020年末最后一天是87版本，就在这个版本中，有一个针对于cookie的API，Cookie Store，这个API代替了我们常用的document.cookie的方法，87版本开始就可以在谷歌浏览器中使用，给大家做一个简单的介绍。如果你要使用的话记得判断对应的浏览器版本，必须大于等于87版本</p><p>判断浏览器版本有很多方法，总的来说就是通过navigator用正则去做对应的匹配，在这里就不多说了</p><h2 id="cookie方法简述"><a href="#cookie方法简述" class="headerlink" title="cookie方法简述"></a>cookie方法简述</h2><p>目前来看，大家在cookie方面都是统一的document.cookie，在此基础上做一些额外的操作，但是通常我们不知道的是，当你设置完成一个cookie信息之后，是否设置成功。你还需要再去获取一下你设置的那个cookie的值，看是否已经成功设置，麻烦不说，还影响我们的执行效率。而且对于正则匹配我们拿出来的所有的cookie信息这种方式很尴尬。cookie是否发生了变更，也没有对应的监听，这些都是要解决的</p><p>自然，有杠精说我存储到localStorage不就完事么？场景不一样，用的内容也不一样，如果有需要，可以复习一下localStorage和cookie的区别</p><p><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2020-12-31/1609407891910-cookie.jpeg" alt="cookie"></p><h2 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h2><p>刚才我们也提到了，目前都是统一通过document.cookie的方式获取的cookie，然后通过对应的匹配形式。为什么我们只想要name这个对应的cookie信息，但总是要先把所有的拿出来，并且还很开心的觉得自己封装了一个好的获取cookie的方法，这总是过于复杂，而且效率很低</p><p>附上一个我们平时封装的获取cookie信息的方式</p><pre><code class="javascript">function getCookie (name) {    let result    return (result = new RegExp(&#39;(?:^|; )&#39; + encodeURIComponent(name) + &#39;=([^;]*)&#39;).exec(document.cookie)) ? decodeURIComponent(result[1]) : null}</code></pre><p>那么如果我们用cookieStore的方式该怎么做呢？</p><p>新的方式的话，需要使用cookieStore并调用其get方法，它返回的是一个promise，所以，当你设置失败的时候，它会告诉你失败并返回失败原因，具体的调用实例如下</p><pre><code class="javascript">try {    const cookieValue = await cookieStore.get(&#39;cookieName&#39;)    if(cookieValue){        console.log(&#39;cookieName: &#39;, cookieValue)    } else {        console.log(&#39;cookieValue is null&#39;)    }} catch(e) {    console.error(&#39;cookieStore is error: &#39; + e)}</code></pre><p>可以发现，这种方式不需要再去遍历一整遍cookie的字段了，当然也不会影响你的同步操作，毕竟这个获取方式是异步的</p><h2 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h2><p>之前我们设置cookie的方式</p><pre><code class="javascript">document.cookie = &#39;cookieName=cookieValue; domain: xxx.com&#39;</code></pre><p>当然你可以把这种形式封装一下，会有一种更好的写法，但是写法是舒服了，本质还是一样的</p><p>就像之前说的，在设置完成之后，如果我们想知道是否设置成功，那么就需要用getCookie获取一遍，如果能够获取到，那说明没问题</p><p>那么在cookieStore中，我们如何设置呢？</p><pre><code class="javascript">try {    await cookieStore.set({        name: &#39;cookieName&#39;,        value: true,        domain: &#39;xxx.com&#39;,        expires: Date.now()    })} catch (e) {    console.error(&#39;falied:&#39; + e)}</code></pre><p>通过上述方式就可以设置一个对应的cookie，当然，只要你不经过catch，它就是设置成功</p><h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><p>之前的方式，我们通常是通过setCookie的形式将对应的cookie的值设置成空，然后将expires的值设置成过期的时间，这样依靠浏览器就会自动删除其对应的内容，这里不再列举</p><p>那么新的方式如何做呢？</p><pre><code class="javascript">try {    await cookieStore.delete(&#39;cookieName&#39;)} catch (e) {    console.error(&#39;falied:&#39; + e)}</code></pre><p>只要没走到catch，那表明删除已经发生并且是正常的</p><h2 id="监控cookie"><a href="#监控cookie" class="headerlink" title="监控cookie"></a>监控cookie</h2><p>当然，新的API肯定有新的方法，那就是你可以监控cookie，当cookie内容发生变化的时候会执行此操作</p><pre><code class="javascript">cookieStore.addEventListener(&#39;change&#39;, event =&gt; {    console.log(`${event.changed.length} changed cookies`)    for (const cookie in event.changed) {        console.log(`${cookie.name} changed`)    }    console.log(`${event.deleted.length} deleted cookies`)    for (const cookie in event.deleted) {        console.log(`${cookie.name} deleted`)    }})</code></pre><h2 id="cookie有哪些属性"><a href="#cookie有哪些属性" class="headerlink" title="cookie有哪些属性"></a>cookie有哪些属性</h2><p>平时的cookie获取可以使用document.cookie进行获取，是由键值对组成，一个;号和一个空格隔开。但是这个方法只能获取非HttpOnly类型的cookie</p><p>设置cookie属性的时候，也是由一个分号和一个空格隔开</p><ul><li>expires：设置cookie有效期，必须是GMT格式时间，可通过new Date().toGMTString()来获得，如果没有设置时间，那么是会话级cookie，浏览器关闭，cookie消失。http/1.1中由Max age代替，有效期为创建时间加Max age</li><li>domain 域名，子域名</li><li>path 路径，子路径 跨域请求满足但是cookie也不会自动被添加</li><li>size cookie的大小</li><li>secure cookie只有在确保安全的请求才会发送，当请求是https或者其他安全协议的时候，包含这个选项的cookie才会被发送，默认这个选项为空，所以任何请求都会携带。如果想要设置这个值，必须确保网页是https协议的才能够去设置</li><li>HttpOnly 设置cookie是否能够通过js访问，有这个选项的表示客户端无法通过js代码去读取，修改，以及删除的操作。而且这个选项是不能通过js修改的，必须服务端才能够设置这个相关的值。并且document.cookie也是获取不到有这个属性的cookie内容的</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>针对以上，似乎chrome团队已经解决了我们的对于cookie的问题，并且这些内容在我们认为理所应当应该存在的东西，但是还是能够希望大家能够很好的去使用，有机会体验一次如果你的项目中有需求的话。</p><p>兼容性别忘记，还是要考虑一下的，但是相信，随着科技的不断发展，这些东西肯定终将不会是问题！</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试知识汇总（不断更新）</title>
      <link href="/2020/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2020/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="预加载，懒加载，dns-预解析"><a href="#预加载，懒加载，dns-预解析" class="headerlink" title="预加载，懒加载，dns 预解析"></a>预加载，懒加载，dns 预解析</h3><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="flex-部分"><a href="#flex-部分" class="headerlink" title="flex 部分"></a>flex 部分</h3><p>flex 属性设置之后，float、clear、vertical-align 失效，主轴交叉轴</p><ul><li><p>flex-direction row row-reverse column column-reverse 主轴方向</p></li><li><p>flex-wrap nowrap wrap wrap-reverse 是否换行</p></li><li><p>flex-flow flex-direction 和 flex-wrap 两种的简写</p></li><li><p>justify-content 主轴的对齐方式 flex-start flex-end center space-between space-around</p></li><li><p>align-items 交叉轴对齐方式 flex-start flex-end center baseline（项目的第一行文字的基线对齐） stretch（未设置高度占满容器，默认值）</p></li><li><p>align-content 多根轴线的对齐方式</p></li><li><p>order item 排列顺序，数值小靠前，默认 0</p></li><li><p>flex-grow item 的放大比例，默认为 0</p></li><li><p>flex-shrink item 缩小比例，默认 1，如果为 0，空间不足不变化</p></li><li><p>flex-basis item 占据的主轴空间，默认 auto，可以设置 px 大小</p></li><li><p>flex 是 flex-grow flex-shrink flex-basis 的简写，快捷值 auto（1 1 auto）none (0 0 auto)</p></li><li><p>align-self 修改 item 的对其方式</p></li></ul><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>块级格式化上下文（不管内部怎么变化都不会表现在外部），可创建的情形（根元素 html，float 不是 none，position 为 absolute 或 fixed，display 的 inline-block、table、flow-root、flex 和 grid 的直接子元素，overflow 不为 visible，contain 为 layout 等，）</p><p>外边距合并问题，可清除浮动，BFC 可包含浮动元素，左右两栏自适应布局（左侧元素浮动，右侧触发 BFC）</p><h3 id="CSS-模块化"><a href="#CSS-模块化" class="headerlink" title="CSS 模块化"></a>CSS 模块化</h3><ul><li>使用 js 或者 json 来写样式</li><li>webapck 的模块化方式</li><li>css modules，作用域</li></ul><ol start="4"><li>双飞翼和圣杯布局区别以及共同点</li><li>1px 问题，rem，em，px</li><li>一个 div 块宽度不固定高度是宽度的一半</li><li>多个 img 并排会有间隙，怎么处理间隙问题 font-size:0</li></ol><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ol><li>js 基本</li><li>函数柯理化</li><li>promise 有哪些属性，如 promise.all 等，then 的参数有几个，对应类型，为什么 pending 时，要将其放进 setTimeout 中</li><li>微任务，宏任务，eventLoop 原理</li><li>实现一个 LazyMan</li><li>Cordova 与 H5 交互原理</li><li>promise，generator，async/await 有什么区别</li><li>防抖截流</li><li>实现 bind，call，apply</li><li>forEach，for…in…，for…of…的区别</li><li>script 标签的 defer 和 async 属性</li><li>require 和 import 有什么区别</li><li>日期的 api 有哪些，array 的 api 有哪些</li><li>jsonp 的原理</li><li>跨域相关，jsonp 的 script 的回调是什么格式</li><li>数组扁平化，去重</li><li>原型链<br><img src="https://gitee.com/RenYaNan/wx-photo/raw/master/2021-1-28/1611806852815-prototype.webp" alt="原型链"></li><li>深浅拷贝，如何处理循环引用</li><li>this 指向</li><li>箭头函数和普通函数的区别？写法原型 this 可以 new 么？</li><li>变量提升，let const，函数提升优先于变量提升</li><li>手写一个发布订阅模式</li></ol><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ol><li>vue 双向绑定原理（watcher 是在什么时候执行的）</li><li>Vue 中是如何检测数组变化</li><li>nextTick 实现原理，为什么他可以拿到 dom</li><li>虚拟 dom，以及 dom-diff</li><li>vue-router 原理（不用 hash 模式服务端如何配置）</li><li>vue3 做了哪些优化</li><li>vue-key</li><li>父子组件生命周期的关系</li><li>data 为什么用 return</li><li>vuex 核心概念，如何实现每个组件实例都有 Store</li><li>vue 动态组件</li><li>服务端渲染</li><li>数组如何监控</li><li>keep-alive 缓存的是整个组件么</li><li>为什么 Vue3.0 要重写响应式系统</li><li>路由守卫是如何触发的，hash 路由，history 路由如何监听路由改变</li><li><code>$on、$emit</code>的实现</li><li>页面权限问题，路由权限</li><li>v-model 的实现</li><li>如何实现按需加载</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>React 原理以及相关</li></ol><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ol><li>小程序的底层实现原理</li></ol><h2 id="TS-相关"><a href="#TS-相关" class="headerlink" title="TS 相关"></a>TS 相关</h2><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ol><li>webpack 打包如何优化</li><li>webpack 配置项都有哪些</li><li>其中 loader 和 plugin 有什么区别，两者差异</li><li>有没有看过或者写过 webpack 的插件</li><li>webpack 如何处理循环应用，作用域相关</li></ol><h2 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h2><ol><li>强缓存和协商缓存&amp;四级缓存</li><li>输入 url 到展示 dom</li><li>内容安全策略 cps</li><li>两个不同域的页面如何进行信息传递</li><li>如何判断 webp 可用</li><li>cookie 有哪些属性，分别表示什么</li><li>content-type 的类型</li><li>https</li><li>TCP 三次握手四次挥手</li><li>XSS、CSRF、中间人攻击</li><li>浏览器缓存–cookies、sessionStorage、localStorage、indexedDB</li></ol><h2 id="http-相关"><a href="#http-相关" class="headerlink" title="http 相关"></a>http 相关</h2><ol><li>https 加密流程，http 缓存</li><li>301 和 302 区别</li><li>http1，1.0，2.0</li><li>同时发起</li><li>spdy 协议</li><li>dns 缓存，查找顺序</li><li>多路复用，header 压缩</li></ol><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ol><li>线程和进程的区别</li><li>观察者模式与发布订阅者模式区别</li><li>七层网络，https 运行在哪一层</li><li>大量数据的 table 怎么处理</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>生成随机数组，洗牌算法</li><li>切割千分位</li><li>找出非降序数列的个数输入：[“cba”, “daf”, “ghi”]输出：1</li><li>找出绝对值最小的数字</li><li>一个正整数的所有质因数</li><li>js 实现链表</li><li>洗牌算法</li><li>爬楼梯，两数之和</li><li>给出一系列版本号，将版本号排序，用数组排序</li><li>链表的环？两个链表找出第一个相交的元素</li><li>数组展平：reduce，去重 set，升序排序算法等</li><li>括号配对</li><li>[-2000, …., +2000]的数组，找出所有和为 8 的一组数的位置</li><li>使用正则去掉字符的尾空格</li><li>排序算法以及其时间复杂度</li><li>设计模式哪些</li><li>二叉树的遍历</li><li>实现一个最大长度的无重复子串的返回，注意不是最大长度，是子串本身</li></ol><h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><ol><li>实现 add(1)(2)(3)</li><li>手写函数柯里化</li><li>promise 手写</li></ol><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><ol><li>qiankun 的原理，如何做到主应用和子应用彼此隔离</li></ol><h2 id="个人相关"><a href="#个人相关" class="headerlink" title="个人相关"></a>个人相关</h2><ol><li>未来发展规划</li></ol><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><h3 id="微任务宏任务"><a href="#微任务宏任务" class="headerlink" title="微任务宏任务"></a>微任务宏任务</h3><p>打印顺序</p><pre><code class="javascript">async function async1() {  console.log(&quot;a&quot;);  await async2();  console.log(&quot;b&quot;);}async function async2() {  console.log(&quot;c&quot;);}console.log(&quot;d&quot;);setTimeout(function () {  console.log(&quot;e&quot;);}, 0);async1();new Promise(function (resolve) {  console.log(&quot;f&quot;);  resolve();}).then(function () {  console.log(&quot;g&quot;);});console.log(&quot;h&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2020/12/hello-world/"/>
      <url>/2020/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>记录一些发生的东西，通过这种方式给自己对应的激励。</p><p>面试总结</p><p>记录汇总</p><p>前端相关</p><p>做这个内容的初衷</p><p>其实原本就是想做一个属于自己的内容库，但是一直一直都在觉得怎么弄怎么做能够好一些，在这个互联网的时代，一个前端开发应该有一个属于自己的东西记录着一切，那就从自己的这个网站开始，也算是简单有了一个开场白吧</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
